%methods

\part{Methods}
\label{sec:methods}

\chapter{Quantum Chemical Programs}
\label{sec:quantumchemicalprograms}

\chapter{The Program \textsc{Spheres}}
\label{sec:theprogramspheres}

On the following pages the program package \textsc{Spheres} will be explained
in detail. It was necessary to develop this code because of the projects in
chapters~\ref{sec:fromstickyhardspheretoLJtypeclusters} and
\ref{sec:thegregorynewtonclusters}. These required routines to optimise a given
starting cluster geometry and analyse the results. The optimisation routine
needed to be flexible in the way that it would be easy to implement different
two-body potentials like Lennard-Jones or extended Lennard-Jones. The program
was written in standard \Cpp and was tested to compile in a Linux environment
with the \verb|clang++| compiler version 3.8.

\section{General Structure}
\label{sec:generalstructure}

Most of the functions and classes of the program are contained in header files,
that can be included in any code file. This allows the package to be quite
flexible while maintaining readability of the code.

%%%cite coord3d and matrix3d
The most fundamental functions are contained in the \verb|geometry.h| header
file which contains the classes responsible for holding triplets of coordinates
(\verb|coord3d|) and to perform basic 3x3 matrix algebra (\verb|matrix3d|).
These classes define functions and operators to perform basic vector and matrix
operations and based on classes developed by ~~~.

Each triplet of coordinates represents a sphere in a cluster and is stored in
an individual object for each unique cluster. This is the purpose of the
\verb|structure| class that will be explained in more detail in the next
section.

The form of the potential is handled in the \verb|pairPotential| class and,
also, will be explained later in the text.

All these different classes are combined into three main programs:
\verb|optimize|, \verb|analyze| and \verb|match|. The first one is concerned
purely with optimising a set of input structures based on a chosen two-body
potential. The results of this procedure can be analysed with the second
program to get the number of unique structures after the optimisation. The last
program matches a set of structures with another set and outputs missing
structures in either set.

\section{The \texttt{structure} Class}
\label{sec:thestructureclass}

The \verb|structure| class provides methods to store coordinates of cluster
geometries and holds functions to calculate properties like energy and moment
of inertia and store them together with the coordinates in the same object. The
class relies on the \verb|coord3d| class for the storage of the coordinates of
the individual spheres.  When an object of this class is created by providing a
set of cartesian coordinates the center of the structure will be moved to the
center of mass of the system and the structure will be rotated such that the
main axis align with the principal axis of the structure. Additionally, all
inter-particle distances will be calculated and stored in the object so that
they are readily available for analysis.

For graph theoretical analysis the class provides functions to calculate
adjacency matrices and graphs based on the \textit{boost graph
library}\autocite{_boost_2002}. These methods take a threshold number that
defines the distance between two spheres at which they are considered
connected.

\section{The \texttt{pairPotential} Class}
\label{sec:thepairpotentialclass}

The \texttt{pairPotential} class provides an easy method to implement arbitrary
potential forms that only depend on the distance between two spheres, so called
two-body potentials. The implementation takes advantage of \Cpp's class
hierarchy, which allows to define subclasses that inherit members from a base
class.

At the core the abstraction works the following. Let $\mathbf{x}_i$ be the
cartesian coordinates of sphere $i$ and the collection of all the coordinates
of all $N$ spheres in the system shall be denoted $\mathbf{X}$.
%
\begin{align}
    \begin{aligned}
        \mathbf{X}=(\mathbf{x}_1,\mathbf{x}_2,\ldots,\mathbf{x}_N,)&=(x_1,x_2,\ldots,x_{3N}) \\
            \mathbf{x}_i &= (x_{3i-2},x_{3i-1},x_{3i})
    \end{aligned}
\end{align}%
%
The distance between two spheres $i$ and $j$ is now given by the norm of the
distance vector $\mathbf{r}_{ij}$.

\begin{align}
    \mathbf{r}_{ij}=\mathbf{x}_i-\mathbf{x}_j=
    \begin{pmatrix}
        x_{3i-2} - x_{3j-2}\\
        x_{3i-1} - x_{3j-1}\\
        x_{3i} - x_{3j}
    \end{pmatrix}\label{eq:distancevector}\\
    |\mathbf{r}_{ij}|=r_{ij}=\sqrt{(x_{3i-2} - x_{3j-2})^2 + (x_{3i-1} - x_{3j-1})^2 + (x_{3i} - x_{3j})^2}\label{eq:distance}
\end{align}
%
The energy of the system is a function of all sphere coordinates $\mathbf{X}$,
but it can be rewritten in terms of an energy function $\varepsilon(r_{ij})$ that only depends on the
distance between two spheres.

\begin{align}
    E(\mathbf{X})=\sum_{j>i}^N\varepsilon(r_{ij})
\end{align}%
%

The gradient of the system is a vector of $3N$ numbers, where each component
refers to the gradient with respect to each coordinate $x$. The derivative with
respect to the $m$th coordinate $x_m$ can be expressed as:

\begin{align}
    \pdv{E(\mathbf{X})}{x_m}=\sum_{j>i}^N\pdv{\varepsilon(r_{ij})}{r_{ij}}\ \pdv{r_{ij}}{\mathbf{r}_{ij}}\ \pdv{\mathbf{r}_{ij}}{x_m}.\label{eq:gradientcomponent}
\end{align}%
%
It is clear, that the terms that contain vectors are separated from the energy
function. This means that the energy term can be exchanged easily without
having to change all parts of the routine. The first term represents the
derivative of the energy function with respect to the distance between two
spheres. From equations~\eqref{eq:distancevector} and \eqref{eq:distance}
follows for the second partial derivative the normalised form of the distance
vector $\mathbf{r_{ij}}$.

\begin{align}
    \pdv{r_{ij}}{\mathbf{r}_{ij}}=\frac{\mathbf{r}_{ij}}{r_{ij}}
\end{align}%
%
The last term is responsible for the right sign of the gradient component and
is best explained by giving an example. Firstly, if $x_m$ is neither in sphere
$i$ nor in $j$ its result is a zero vector making the whole expression vanish.
Let's assume $m=3i+1$, then the last expression becomes:

\begin{align}
    \pdv{\mathbf{r}_{ij}}{x_{3i-1}}=
    \begin{pmatrix}
        0\\1\\0
    \end{pmatrix}.
\end{align}%
%
For this example the scalar product of this vector with the normalised distance
vector $\mathbf{r}_{ij}$ is $\frac{1}{r_{ij}}(x_{3i-1} - x_{3j-1})$. Therefore,
the last term ensures that the $m$th component of the gradient vector only
collects contributions from interactions between spheres that contain the
coordinate $x_m$. If $m$ was a coordinate present in sphere $j$ the last term
swaps the sign of the gradient. This is a result of the fact, that the gradient
at sphere $j$ should be opposite of the gradient at sphere $i$. The final
gradient is given by calculating all partial derivatives with respect to $x_m$.

\begin{align}
    \dv{E(\mathbf{X})}{\mathbf{X}}=
    \begin{pmatrix}
        \pdv*{E(\mathbf{X})}{x_1}\\
        \pdv*{E(\mathbf{X})}{x_2}\\
        \vdots\\
        \pdv*{E(\mathbf{X})}{x_{3N}}
    \end{pmatrix}
\end{align}

The separation of the vector and scalar components allows for easy exchange of
the energy functions as the calculations that take care of the direction of the
gradient can be completely separated out. In the program, the
\texttt{pairPotential} base class contains the routines concerned with the last
to terms of equation~\eqref{eq:gradientcomponent}, while the functions for
energy and gradient are declared to be \texttt{virtual}. They are only defined
in the classed derived from the base class.

The same procedure can be applied to the second derivative to calculate a
Hessian matrix. Again, the important part is to separate the scalar energy
function from vector parts. This leads to the following equations.

\begin{align}
    \pdv{E(\mathbf{X})}{x_m}{x_n}=\sum_{j>i}^N\left[  
    \begin{array}{ll}
    \pdv[2]{\varepsilon(r_{ij})}{{r_{ij}}}\  
    \pdv{r_{ij}}{\mathbf{r}_{ij}}\ 
    \pdv{\mathbf{r}_{ij}}{x_m}\ 
    \pdv{r_{ij}}{\mathbf{r}_{ij}}\ 
    \pdv{\mathbf{r}_{ij}}{x_n} \\ 
    +
    \pdv{\varepsilon(r_{ij})}{r_{ij}}\
        \pdv[2]{r_{ij}}{{\mathbf{r}_{ij}}}\ 
    \pdv{\mathbf{r}_{ij}}{x_m}\ 
    \pdv{\mathbf{r}_{ij}}{x_n} 
    \end{array}
    \right]\\
    \begin{aligned}
    \dv[2]{E(\mathbf{X})}{\mathbf{X}}=\\
    \begin{pmatrix}
        \pdv*[2]{E(\mathbf{X})}{{x_1}} & \pdv*{E(\mathbf{X})}{x_1}{x_2} & \ldots & \pdv*{E(\mathbf{X})}{x_1}{x_{3N}}\\
        \pdv*{E(\mathbf{X})}{x_2}{x_1} & \pdv*[2]{E(\mathbf{X})}{{x_2}} & \ldots & \pdv*{E(\mathbf{X})}{x_2}{x_{3N}}\\
        \vdots & \vdots & \ddots & \vdots\\
        \pdv*{E(\mathbf{X})}{x_{3N}}{x_1} & \pdv*{E(\mathbf{X})}{x_{3N}}{x_2} & \ldots & \pdv*[2]{E(\mathbf{X})}{{x_{3N}}}
    \end{pmatrix}
    \end{aligned}
\end{align}

\section{Optimisation of Input Structures}
\label{sec:optimisationofinputstructures}

The first main program is \verb|optimize|. It reads in coordinates from an
input file and creates a \verb|structure| object for each cluster. The
structures will be moved to their center of mass and rotated into the principal
axis system automatically. If a scaling factor is provided in the
\verb|settings| file the structures will be scaled accordingly.  The
optimisation is parallelised using simple \ac{OMP} \verb|for|-loop
parallelisation and can be controlled with the environment variable
\verb|OMP_NUM_THREADS| in a unix environment.

After each structural optimisation the program checks if the structure is a
true minimum by calculation the Hessian matrix eigenvalues. If this check fails
the eigenvectors of the Hessian matrix are calculated and the non-minimum
structure is displaced according to eigenvector belonging to the first negative
eigenvalue in the Hessian matrix.

The resulting structures are printed in the file \verb|coord| as plain
three-dimensional coordinates.

\section{Analysing Results}
\label{sec:analysingresults}

The optimisation procedure usually lead to the creation of duplicate
structures. To eliminate the duplicate structures the program \verb|analyze|
was created. It reads in all structures from the file \verb|coord| and
calculates their energies using \ac{OMP} parallelisation based on the chosen
potential model.

Finding equivalent structures is a task far from triviality. The program
\verb|analyze| relies on two methods using different properties of the
structures to sort them into groups.

The first method uses four values to uniquely identify a structure. Those are
the values for energy and the three eigenvalues of the moment of inertia
tensor. This sorting procedure uses \Cpp's \verb|map| feature, which uses a
binary search tree as its data structure. This allows the algorithm to scale
well with the number of optimised structures. The \Cpp \verb|map| object
contains a \verb|key| and a \verb|value| field and elements of a \verb|map| are
guaranteed to be stored in
order.\autocite{Cormen_IntroductionAlgorithms3rd_2009} In this specific case
the ordering is done by energy first, then smallest moment of inertia tensor
eigenvalue followed by the two other moment of inertia tensor eigenvalues. The
advantage of this method is its great scalability with respect to the number of
optimised structures.  However, over the course of the calculations it was
noticed that the methods shows deviations for larger exponents. Therefore, a
second method was implemented.

The second method uses the matrix of all inter-particle distances as the
differentiation criterion. If at least one inter-particle distance is different
two structures are said to be not equal. As there is no clear answer to the
question which distance matrix is ``larger'' than another one the
implementation could not be handled by using a \verb|map| container. A regular
two-dimensional \verb|vector| array is used instead. A structure's distance
matrix is compared to the distance matrix of an already sorted structure and is
added to the same group if they are equal. If not, the structure is added to
the array as a new group. The more unique structures the optimisation produced
the slower this method of sorting becomes, but the results are more reliable
than the previously discussed ones.

\section{Matching Structures}
\label{sec:matchingstructures}

\section{Apps}
\label{sec:apps}
