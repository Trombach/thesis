%methods

\part{Methods}
\label{sec:methods}

\chapter{Quantum Chemical Programs}
\label{sec:quantumchemicalprograms}

\chapter{The Program \textsc{Spheres}}
\label{sec:theprogramspheres}

Chapters~\ref{sec:fromstickyhardspheretoLJtypeclusters} and
\ref{sec:thegregorynewtonclusters} required methods to optimise and analyse
arbitrary cluster structures based on a potential depending only on the
distance between two spheres. For this purpose the program package
\textsc{Spheres} was developed in \Cpp. The following chapters contain
information about the most important classes and functions of the program.

\section{General Structure}
\label{sec:generalstructure}

Most of the functions and classes of the program are contained in header files,
that can be included in any code file. This allows the package to be quite
flexible while maintaining readability of the code.

The most basic header file is \verb|geometry.h| which contains the classes
responsible for holding triplets of coordinates (\verb|coord3d|) and to
perform basic 3x3 matrix algebra (\verb|matrix3d|).

\section{The \texttt{structure} Class}
\label{sec:thestructureclass}

The \verb|structure| class provides methods to store coordinates of cluster
geometries and holds functions to calculate properties like energy and moment
of inertia and store them together with the coordinates in the same object. The
class relies on the \verb|coord3d| class for the storage of the coordinates of
the individual spheres.  When an object of this class is created by providing a
set of cartesian coordinates the center of the structure will be moved to the
center of mass of the system and the structure will be rotated such that the
main axis align with the principal axis of the structure. Additionally, all
inter-particle distances will be calculated and stored in the object so that
they are readily available for analysis.

For graph theoretical analysis the class provides functions to calculate
adjacency matrices and graphs based on the \textit{boost graph
library}\autocite{_boost_2002}. These methods take a threshold number that
defines the distance between two spheres at which they are considered
connected.

\section{The \texttt{pairPotential} Class}
\label{sec:thepairpotentialclass}

The \texttt{pairPotential} class provides an easy method to implement arbitrary
potential forms that only depend on the distance between two spheres, so called
two-body potentials. The implementation takes advantage of \Cpp's class
hierarchy, which allows to define subclasses that inherit members from a base
class.

At the core the abstraction works the following. Let $\mathbf{x}_i$ be the
cartesian coordiantes of sphere $i$ and the collection of all the coordinates
of all $N$ spheres in the system shall be denoted $\mathbf{X}$.
%
\begin{align}
    \begin{aligned}
        \mathbf{X}=(\mathbf{x}_1,\mathbf{x}_2,\ldots,\mathbf{x}_N,)&=(x_1,x_2,\ldots,x_{3N}) \\
            \mathbf{x}_i &= (x_{3i},x_{3i+1},x_{3i+2})
    \end{aligned}
\end{align}%
%
The distance between two spheres $i$ and $j$ is now given by the norm of the
distance vector $\mathbf{r}_{ij}$.

\begin{align}
    \mathbf{r}_{ij}=\mathbf{x}_i-\mathbf{x}_j=
    \begin{pmatrix}
        x_{3i} - x_{3j}\\
        x_{3i+1} - x_{3j+1}\\
        x_{3i+2} - x_{3j+2}
    \end{pmatrix}\label{eq:distancevector}\\
    |\mathbf{r}_{ij}|=r_{ij}=\sqrt{(x_{3i} - x_{3j})^2 + (x_{3i+1} - x_{3j+1})^2 + (x_{3i+2} - x_{3j+2})^2}\label{eq:distance}
\end{align}
%
The energy of the system is a function of all sphere coordinates $\mathbf{X}$,
but it can be rewritten in terms of an energy function $\varepsilon(r_{ij})$ that only depends on the
distance between two spheres.

\begin{align}
    E(\mathbf{X})=\sum_{j>i}^N\varepsilon(r_{ij})
\end{align}%
%

The gradient of the system is a vector of $3N$ numbers, where each component
refers to the gradient with respect to each coordinate $x$. The derivative with
respect to the $m$th coordinate $x_m$ can be expressed as:

\begin{align}
    \frac{\partial E(\mathbf{X})}{\partial x_m}=\sum_{j>i}^N\frac{\partial\varepsilon(r_{ij})}{\partial r_{ij}}\ \frac{\partial r_{ij}}{\partial\mathbf{r}_{ij}}\ \frac{\partial\mathbf{r}_{ij}}{\partial x_m}.
\end{align}%
%
It is clear, that the terms that contain vectors are separated from the energy
function. This means that the energy term can be exchanged easily without
having to change all parts of the routine. The first term represents the
derivative of the energy function with respect to the distance between two
spheres. From equations~\eqref{eq:distancevector} and \eqref{eq:distance}
follows for the second partial derivative the normalised form of the distance
vector $\mathbf{r_{ij}}$.

\begin{align}
    \frac{\partial r_{ij}}{\partial\mathbf{r}_{ij}}=\frac{\mathbf{r}_{ij}}{r_{ij}}
\end{align}%
%
The last term is responsible for the right sign of the gradient component and
is best explained by giving an example. Firstly, if $x_m$ is neither in sphere
$i$ nor in $j$ its result is a zero vector making the whole expression vanish.
Let's assume $m=3i+1$, then the last expression becomes:

\begin{align}
    \frac{\partial\mathbf{r}_{ij}}{\partial x_{3i+1}}=
    \begin{pmatrix}
        0\\1\\0
    \end{pmatrix}.
\end{align}%
%
For this example the scalar product of this vector with the normalised distance
vector $\mathbf{r}_{ij}$ is $\frac{1}{r_{ij}}(x_{3i+1} - x_{3j+1})$. Therefore,
the last term ensures that the $m$th component of the gradient vector only
collects contributions from interactions between spheres that contain the
coordinate $x_m$. If $m$ was a coordinate present in sphere $j$ the last term
swaps the sign of the gradient. This is a result of the fact, that the gradient
at sphere $j$ should be opposite of the gradient at sphere $i$. The final
gradient is given by calculation all partial derivatives with respect to $x_m$.

\begin{align}
    \frac{\dif E(\mathbf{X})}{\dif \mathbf{X}}=
    \begin{pmatrix}
        \nicefrac{\partial E(\mathbf{X})}{\partial x_1}\\
        \nicefrac{\partial E(\mathbf{X})}{\partial x_2}\\
        \vdots\\
        \nicefrac{\partial E(\mathbf{X})}{\partial x_{3N}}
    \end{pmatrix}
\end{align}

\section{Optimisation of Input Structures}
\label{sec:optimisationofinputstructures}

\section{Analysing Results}
\label{sec:analysingresults}

\section{Matching Structures}
\label{sec:matchingstructures}

\section{Apps}
\label{sec:apps}
