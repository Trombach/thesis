%methods

\part{Methods}
\label{sec:methods}

\chapter{Quantum Chemical Programs}
\label{sec:quantumchemicalprograms}

\chapter{The Program \textsc{Spheres}}
\label{sec:theprogramspheres}

On the following pages the program package \textsc{Spheres} will be explained
in detail. It was necessary to develop this code because of the projects in
chapters~\ref{sec:fromstickyhardspheretoLJtypeclusters} and
\ref{sec:thegregorynewtonclusters}. These required routines to optimise a given
starting cluster geometry and analyse the results. The optimisation routine
needed to be flexible in the way that it would be easy to implement different
two-body potentials like Lennard-Jones or extended Lennard-Jones. The program
was written in standard \Cpp and was tested to compile in a Linux environment
with the \verb|clang++| compiler version 3.8.

\section{General Structure}
\label{sec:generalstructure}

Most of the functions and classes of the program are contained in header files,
that can be included in any code file. This allows the package to be quite
flexible while maintaining readability of the code.

%%%cite coord3d and matrix3d
The most fundamental functions are contained in the \verb|geometry.h| header
file which contains the classes responsible for holding triplets of coordinates
(\verb|coord3d|) and to perform basic 3x3 matrix algebra (\verb|matrix3d|).
These classes define functions and operators to perform basic vector and matrix
operations and based on classes developed by ~~~.

Each triplet of coordinates represents a sphere in a cluster and is stored in
an individual object for each unique cluster. This is the purpose of the
\verb|structure| class that will be explained in more detail in the next
section.

The form of the potential is handled in the \verb|pairPotential| class and,
also, will be explained later in the text.

All these different classes are combined into three main programs:
\verb|optimize|, \verb|analyze| and \verb|match|. The first one is concerned
purely with optimising a set of input structures based on a chosen two-body
potential. The results of this procedure can be analysed with the second
program to get the number of unique structures after the optimisation. The last
program matches a set of structures with another set and outputs missing
structures in either set.

\section{The \texttt{structure} Class}
\label{sec:thestructureclass}

The \verb|structure| class provides methods to store coordinates of cluster
geometries and holds functions to calculate properties like energy and moment
of inertia and store them together with the coordinates in the same object. The
class relies on the \verb|coord3d| class for the storage of the coordinates of
the individual spheres.  When an object of this class is created by providing a
set of cartesian coordinates the center of the structure will be moved to the
center of mass of the system and the structure will be rotated such that the
main axis align with the principal axis of the structure. Additionally, all
inter-particle distances will be calculated and stored in the object so that
they are readily available for analysis.

For graph theoretical analysis the class provides functions to calculate
adjacency matrices and graphs based on the \textit{boost graph
library}\autocite{_boost_2002}. These methods take a threshold number that
defines the distance between two spheres at which they are considered
connected.

\section{The \texttt{pairPotential} Class}
\label{sec:thepairpotentialclass}

The \texttt{pairPotential} class provides an easy method to implement arbitrary
potential forms that only depend on the distance between two spheres, so called
two-body potentials. The implementation takes advantage of \Cpp's class
hierarchy, which allows to define subclasses that inherit members from a base
class.

At the core the abstraction works the following. Let $\mathbf{x}_i$ be the
cartesian coordinates of sphere $i$ and the collection of all the coordinates
of all $N$ spheres in the system shall be denoted $\mathbf{X}$.
%
\begin{align}
    \begin{aligned}
        \mathbf{X}=(\mathbf{x}_1,\mathbf{x}_2,\ldots,\mathbf{x}_N,)&=(x_1,x_2,\ldots,x_{3N}) \\
            \mathbf{x}_i &= (x_{3i},x_{3i+1},x_{3i+2})
    \end{aligned}
\end{align}%
%
The distance between two spheres $i$ and $j$ is now given by the norm of the
distance vector $\mathbf{r}_{ij}$.

\begin{align}
    \mathbf{r}_{ij}=\mathbf{x}_i-\mathbf{x}_j=
    \begin{pmatrix}
        x_{3i} - x_{3j}\\
        x_{3i+1} - x_{3j+1}\\
        x_{3i+2} - x_{3j+2}
    \end{pmatrix}\label{eq:distancevector}\\
    |\mathbf{r}_{ij}|=r_{ij}=\sqrt{(x_{3i} - x_{3j})^2 + (x_{3i+1} - x_{3j+1})^2 + (x_{3i+2} - x_{3j+2})^2}\label{eq:distance}
\end{align}
%
The energy of the system is a function of all sphere coordinates $\mathbf{X}$,
but it can be rewritten in terms of an energy function $\varepsilon(r_{ij})$ that only depends on the
distance between two spheres.

\begin{align}
    E(\mathbf{X})=\sum_{j>i}^N\varepsilon(r_{ij})
\end{align}%
%

The gradient of the system is a vector of $3N$ numbers, where each component
refers to the gradient with respect to each coordinate $x$. The derivative with
respect to the $m$th coordinate $x_m$ can be expressed as:

\begin{align}
    \dv{E(\mathbf{X})}{x_m}=\sum_{j>i}^N\pdv{\varepsilon(r_{ij})}{r_{ij}}\ \pdv{r_{ij}}{\mathbf{r}_{ij}}\ \pdv{\mathbf{r}_{ij}}{x_m}.\label{eq:gradientcomponent}
\end{align}%
%
It is clear, that the terms that contain vectors are separated from the energy
function. This means that the energy term can be exchanged easily without
having to change all parts of the routine. The first term represents the
derivative of the energy function with respect to the distance between two
spheres. From equations~\eqref{eq:distancevector} and \eqref{eq:distance}
follows for the second partial derivative the normalised form of the distance
vector $\mathbf{r_{ij}}$.

\begin{align}
    \pdv{r_{ij}}{\mathbf{r}_{ij}}=\frac{\mathbf{r}_{ij}}{r_{ij}}
\end{align}%
%
The last term is responsible for the right sign of the gradient component and
is best explained by giving an example. Firstly, if $x_m$ is neither in sphere
$i$ nor in $j$ its result is a zero vector making the whole expression vanish.
Let's assume $m=3i+1$, then the last expression becomes:

\begin{align}
    \pdv{\mathbf{r}_{ij}}{x_{3i+1}}=
    \begin{pmatrix}
        0\\1\\0
    \end{pmatrix}.
\end{align}%
%
For this example the scalar product of this vector with the normalised distance
vector $\mathbf{r}_{ij}$ is $\frac{1}{r_{ij}}(x_{3i+1} - x_{3j+1})$. Therefore,
the last term ensures that the $m$th component of the gradient vector only
collects contributions from interactions between spheres that contain the
coordinate $x_m$. If $m$ was a coordinate present in sphere $j$ the last term
swaps the sign of the gradient. This is a result of the fact, that the gradient
at sphere $j$ should be opposite of the gradient at sphere $i$. The final
gradient is given by calculating all partial derivatives with respect to $x_m$.

\begin{align}
    \dv{E(\mathbf{X})}{\mathbf{X}}=
    \begin{pmatrix}
        \pdv*{E(\mathbf{X})}{x_1}\\
        \pdv*{E(\mathbf{X})}{x_2}\\
        \vdots\\
        \pdv*{E(\mathbf{X})}{x_{3N}}
    \end{pmatrix}
\end{align}

The separation of the vector and scalar components allows for easy exchange of
the energy functions as the calculations that take care of the direction of the
gradient can be completely separated out. In the program, the
\texttt{pairPotential} base class contains the routines concerned with the last
to terms of equation~\eqref{eq:gradientcomponent}, while the functions for
energy and gradient are declared to be \texttt{virtual}. They are only defined
in the classed derived from the base class.

The same procedure can be applied to the second derivative to calculate a
Hessian matrix. Again, the important part is to separate the scalar energy
function from vector parts. This leads to the following equations.

\begin{align}
    \pdv{E(\mathbf{X})}{x_m}{x_n}=\sum_{j>i}^N\left[  
    \begin{array}{ll}
    \pdv[2]{\varepsilon(r_{ij})}{{r_{ij}}}\  
    \pdv{r_{ij}}{\mathbf{r}_{ij}}\ 
    \pdv{\mathbf{r}_{ij}}{x_m}\ 
    \pdv{r_{ij}}{\mathbf{r}_{ij}}\ 
    \pdv{\mathbf{r}_{ij}}{x_n} \\ 
    +
    \pdv{\varepsilon(r_{ij})}{r_{ij}}\
        \pdv[2]{r_{ij}}{{\mathbf{r}_{ij}}}\ 
    \pdv{\mathbf{r}_{ij}}{x_m}\ 
    \pdv{\mathbf{r}_{ij}}{x_n} 
    \end{array}
    \right]\\
    \begin{aligned}
    \dv[2]{E(\mathbf{X})}{\mathbf{X}}=\\
    \begin{pmatrix}
        \pdv*[2]{E(\mathbf{X})}{{x_1}} & \pdv*{E(\mathbf{X})}{x_1}{x_2} & \ldots & \pdv*{E(\mathbf{X})}{x_1}{x_{3N}}\\
        \pdv*{E(\mathbf{X})}{x_2}{x_1} & \pdv*[2]{E(\mathbf{X})}{{\partial x_2}} & \ldots & \pdv*{E(\mathbf{X})}{x_2}{x_{3N}}\\
        \vdots & \vdots & \ddots & \vdots\\
        \pdv*{E(\mathbf{X})}{x_{3N}}{x_1} & \pdv*{E(\mathbf{X})}{x_{3N}}{x_2} & \ldots & \pdv*[2]{E(\mathbf{X})}{{x_{3N}}}
    \end{pmatrix}
    \end{aligned}
\end{align}

\section{Optimisation of Input Structures}
\label{sec:optimisationofinputstructures}

The first main program is \verb|optimize|. It reads in coordinates from an
input file and creates a \verb|structure| object for each cluster.  

\section{Analysing Results}
\label{sec:analysingresults}

\section{Matching Structures}
\label{sec:matchingstructures}

\section{Apps}
\label{sec:apps}
