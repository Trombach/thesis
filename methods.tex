%methods

\part{Methods}
\label{sec:methods}

\chapter{Program \textsc{Spheres}}
\label{sec:theprogramspheres}

In the projects outlined in
chapters~\ref{sec:fromstickyhardspheretoLJtypeclusters} and
\ref{sec:thegregorynewtonclusters} a program to optimise 3-dimensional
coordinates of cluster structures with respect to a two-body potential was
required to be created. The optimisation routine needed to be flexible in the
way that it would be easy to implement different two-body potentials like
\ac{LJ} or \ac{eLJ}. Furthermore, the program needed to be able to analyse the
results regarding structure, energy and the matrix of second derivatives. The
resulting program was written in \Cpp and was tested to compile in a Linux
environment with the \texttt{clang++} compiler version 6.0. In the following
sections, main features are explained and more important functionalities are
outlined in more detail.

A final version of the source code will be provided in combination with this
thesis.

\section{Structural Optimisation and Analysis}
\label{sec:generalstructure}

The main functions of the program are implemented in three different executable
programs. Each carries out a different task, i.e. optimising given input
structures and output the results, removing duplicate structures from a set of
input structures and finding differences of two sets of input structures. The
programs are set up in such a way that their outputs can be used as input files
for the other program parts. This allows the programs to be used sequentially
while retaining the flexibility of using each executable program separately.
This chain-like execution scheme is depicted in
figure~\ref{fig:OptimisationAnalyseScheme}. 
%
\begin{figure}[htb]\centering
    \begin{tikzpicture}[node distance = 3cm, scale=0.8, auto, transform shape]%, every node/.style={scale=0.8}]
    \node [cloud] (Input1) {Input structures};
    \node [block, right of=Input1] (Optimise) {Optimise};
    \node [decision, right of=Optimise] (Hessian) {Negative values in Hessian?};
    \node [block, below of=Optimise] (reopt) {Displace geometry};
    \node [cloud, right=1.5cm of Hessian] (print) {Optimised structures};
    \node [block, below of=print] (Analyse) {Analyse $\{r_{ij}\}$};
    \node [cloud, below of=Analyse] (Analysed) {Duplicates removed};
    \node [block, left of=Analysed] (Match) {Match sets};
    \node [cloud, left of=Match] (Input2) {Input structures};
    \node [cloud, below of=Match] (missing) {Missing clusters};

    \path [line] (Input1) -- (Optimise);
    \path [line] (Optimise) -- (Hessian);
    \path [line] (Hessian) |- node {yes} (reopt);
    \path [line] (reopt) -- (Optimise);
    \path [line] (Hessian) -- node {no} (print);
    \path [line] (print) -- (Analyse);
    \path [line] (Analyse) -- (Analysed);
    \path [line] (Analysed) -- (Match);
    \path [line] (Input2) -- (Match);
    \path [line] (Match) -- (missing);

    \node (OptProg) [transform shape=false,draw, color=blue, dashed, thick, %
        fit=(Optimise) (Hessian) (reopt)] {};
    %\node [above=0.1cm of OptProg] {\texttt{Optimize}};

    \node (InputBox1) [draw,color=gray,thick,transform shape=false, fit=(Input1)] {}; 
    \node (InputBox2) [draw,color=gray,thick,transform shape=false, fit=(Input2)] {}; 
    \node (OutputBox1) [draw,color=gray,thick,dashed,transform shape=false, fit=(print)] {}; 
    \node (OutputBox2) [draw,color=gray,thick,dashed,transform shape=false, fit=(Analysed)] {}; 
    \node (OutputBox3) [draw,color=gray,thick,dashed,transform shape=false, fit=(missing)] {}; 
    \node [above=0.1cm of InputBox1] {Input 1};
    \node [below=0.1cm of InputBox2] {Input 2};
    \node [above=0.1cm of OutputBox1] {Output 1};
    \node [below=0.1cm of OutputBox2] {Output 2};
    \node [below=0.1cm of OutputBox3] {Output 3};

\end{tikzpicture}
    \caption{Schematic representation of the optimisation, analysis and
    matching procedure. Red circles: program input or output, blue squares:
    program functions.}
    \label{fig:OptimisationAnalyseScheme}
\end{figure}
%
A set of input structures (Input 1) is provided to the first executable program
\texttt{optimize}, which optimises the structures and generates Output 1, which
is a list of optimised coordinates in the same format as the input. This can be
used as input for the second executable program \texttt{analyze}, which uses
the distance matrix to identify duplicate structures and outputs a list of
optimised structures with no duplicates (Output 2). In combination with a
secondary set of structures (Input 2) the third executable program
\texttt{match} can be used to compare both sets of structures and output
coordinates of structures that are missing from either set 1 or 2 (Output 3). 

\subsection{Optimisation of Input Structures}
\label{sec:optimisationofinputstructures}

The optimisation of input structures with a chosen potential can be carried out
with the program \texttt{optimize}. The coordinates of the input structures
have to be provided in a single file where each line contains three numbers
representing the position of one sphere. Multiple structures can be included by
separating the list of coordinates by single blank lines. The program
automatically moves the input structures to their respective centres of mass,
and rotates them into the principal axis system. To speed up the optimisation
the Unix variable \texttt{OMP\_NUM\_THREADS} can be set to a value greater than
one to enable \ac{OMP} parallelisation. Each optimisation is carried out in a
separate thread, while the number of simultaneously running threads is equal to
\texttt{OMP\_NUM\_THREADS}.

The optimisation can be controlled by setting parameters in the
\texttt{settings} file using the \texttt{opt} keyword. The optimisation model
can be chosen with the \texttt{name} tag, which currently can be set to either
\texttt{BFGS} for the \ac{BFGS} algorithm or \texttt{CG} for the conjugate
gradient method. The optimiser uses the machine learning library
dlib\autocite{King_DlibmlMachineLearning_2009} as a back-end, which allows for
the implementation of additional optimisation models with relative ease. The energy
termination criterion is defined using the \texttt{dforce} tag and the
maximum number of steps can be set with the \texttt{nsteps} tag. An example is
given in the box below.
%\begin{figure}[ht]
%
\begin{Verbatim}[frame=single,label=settings file - opt tag]
opt: {
    name = "BFGS";
    dforce = 1e-10;
    nsteps = 100;
};
\end{Verbatim}
%\end{figure}
%
A potential model has to be chosen for the optimisation procedure. Custom models
can be added easily, which will be explained later. The current implementation
allows the selection of three pair potentials, \ac{LJ}, \ac{eLJ} and a \ac{LJ}
potential with a cut-off range. For the \ac{LJ} potential four parameters have
to be given to the \texttt{potential} tag as shown in the box below.
%
%\begin{figure}[htb]
\begin{Verbatim}[frame=single,label=settings file - potential tag]
potential: {
    name = "LJ";
    epsilon = 1.0;
    rm =  1.0;
    exp1 = 12.0;
    exp2 = 6.0;
};
\end{Verbatim}
%\end{figure}
%
The \texttt{name} tag enables the \ac{LJ} potential to be used and the four
parameters \texttt{epsilon}, \texttt{rm}, \texttt{exp1} and \texttt{exp2} define
the potential. The values shown in the example are the default values, which the
program will fall back to if no values are provided by the user. The \ac{eLJ}
potential can be chosen by setting the \texttt{name} tag to \texttt{ELJ} and a
range cut-off value can be chosen with the \texttt{RangeLJ} potential. For the
\ac{eLJ}potential the $c_n$ coefficients have to be provided in a separate file
named \texttt{ext}, where each line contains two numbers. The first integer
represents $n$ and the second floating point number defines the corresponding
coefficient.

After each structural optimisation the program checks if the result is a true
minimum by calculating the Hessian matrix eigenvalues. If this check fails the
eigenvectors of the Hessian matrix are calculated and the non-minimum structure
is displaced according to the eigenvector belonging to the first negative
eigenvalue in the Hessian matrix. The algorithm tries to re-optimise until there
are no negative eigenvalues in the Hessian matrix or until a maximum number of
five re-optimisations is reached.

The resulting structures are printed in the file \texttt{coord} in the same
format as the input. To analyse the optimisation procedure the additional files
\texttt{opt} and \texttt{reopt} are printed, which contain the intermediate
steps of the optimisation and re-optimisation procedures for each individual
input structure.

\subsection{Removing Duplicate Structures}
\label{sec:analysingresults}

Duplicated geometries in a set of input structures can be identified using the
second sub-program \texttt{analyze}. The input has to be provided in the same
format as for the \texttt{optimize} program. The read-in procedure is
equivalent to the \texttt{optimize} program. The program uses two
methods to identify unique structures, one of which uses the energy of the
cluster as a criterion, therefore the \texttt{potential} tag has to be set in
the \texttt{settings} file.

The first method uses four values to uniquely identify a structure. Those are
the values for energy and the three eigenvalues of the moment of inertia tensor.
This sorting procedure uses a \verb|map| container, which is an implementation
of a binary search tree. This allows the algorithm to scale well with the number
of structures to be analysed. The \verb|map| container contains a \verb|key| and
a \verb|value| field and elements of a \verb|map| are guaranteed to be stored in
order.\autocite{Stroustrup_programminglanguage_2000} In this specific case the
ordering is done by energy first, then smallest moment of inertia tensor
eigenvalue followed by the two larger moment of inertia tensor eigenvalues. The
\texttt{map} container maps the \texttt{key}, which is the combination of energy
and moment of inertia eigenvalues, to a \texttt{value}, which, in this case, is
simply the number of structures. 

The advantage of this method is its great scalability with respect to the
number of input structures as values can be retrieved quickly based on the
key.

The second method uses the \ac{EDM} as the differentiation criterion. The
\ac{EDM} is the matrix of all inter-particle distances $d_{ij}$ where
each entry is defined as the Euclidean norm $||\cdot||$ between to spheres.
%
\begin{align}
    d_{ij}=||\mathbf{x}_i-\mathbf{x}_j||^2
\end{align}
%
The \ac{EDM} represents a unique embedding of the cluster in space, however
information about the absolute position and orientation are lost on creation.
That means rigid transformations of clusters (translations, rotations,
reflections) don't affect the \ac{EDM} as they don't change fixed distances
between points in space.\autocite{Dokmanic_EuclideanDistanceMatrices_2015} If at
least one inter-particle distance is different, the structures are said to be
not equal. The algorithm is implemented such a way that a structure's distance
matrix is compared to the distance matrix of all other already sorted structures
and is added to the matching group if they are equal up to a set threshold. If
not, the structure is added to the array as a new group. If the optimisation
resulted in many unique structure, this method of sorting becomes slow, as each
trial structure has to be compared to all other already sorted structure groups.

\subsection{Matching Structures}
\label{sec:matchingstructures}

To compare the results from the optimisations procedures to previously
published sets of clusters the program \verb|match| can be used. It takes two
files as input that each contain a set of structures of equal of different size
and compares them based on the \ac{EDM}. The number of atoms in each set must
be equal, otherwise the program will be terminated. If both sets are found to
be identical no output files are created. In case there are unmatched
structures they will be printed in \verb|xyz| format in the \verb|output|
directory for further analysis.

\section{Graph-Theoretical Analysis}
\label{sec:GraphTheoreticalAnalysis}

Graph theoretical analysis of cluster structures can be done with
\verb|ico-subgraph|, which is a very specialised program designed to compare
contact graphs of \ac{GN} clusters to the icosahedral graph. The input format
for the structures remains unchanged. 

All graph objects are handled by the \textit{boost graph
library}\autocite{Siek_BoostGraphLibrary_2002} and are implemented as
undirected graphs as the direction of the connectivity in clusters is
not meaningful. The graphs are automatically generated from three-dimensional
coordinate input given by an object of type \verb|structure|. Two types of
graphs can be generated from these: (1) the graph of the complete structure and
(2) the contact graph containing all spheres but the central one (if it
exists). The latter is the more important one as it was used to carry out the
analyses in chapter~\ref{sec:thegregorynewtonclusters}. The decision whether
two spheres are connected is based on two parameters, the equilibrium distance
and a threshold value. The default values for these are $1$ and $10^{-10}$,
respectively.

The icosahedral graph is generated from three-dimensional coordinate input and
is compared to the input structures via their graphs and the \textit{VF2}
algorithm.\autocite{Cordella_ImprovedAlgorithmMatching_2001,Cordella_SubGraphIsomorphism_2004}
The algorithm finds all mappings of the vertices of the icosahedral graph to
the graph of the input structure. As the icosahedron represents the complete
planar graph for 12 vertices, every graph that is a subgraph of the icosahedral
graph can be represented by the number and type of edges removed from the
icosahedral graph. For this application the mapping was chosen based on the
\ac{RMS} value of the distances between the spheres formerly connected by edges
in the icosahedral graph. From all the possible mappings of the investigated
graphs to the icosahedral graph the one with the lowest \ac{RMS} value was
chosen.

The graphs of the input structures are analysed with respect to their vertex
and face degrees. Vertex degrees are calculated directly by the library and can
be accessed with the \verb|degree| function. For face degrees the
\verb|planar_face_traversal| function has to be invoked. This algorithm
iterates over all faces in the planar embedding counting the number of vertices
constructing each face. The graphs of the input structures are then sorted
based on the calculated degree values, starting with the vertex degree in
descending order and followed by the face degree in ascending order. If two or
more graphs have the same amount of face and vertex degrees they are grouped
together. The sorted graphs are printed to the standard output in the same form
as table~\ref{tab:verticesandfaces} (page~\pageref{tab:verticesandfaces}).
Additionally, the investigated graphs are printed in terms of removed edges
from the icosahedral graph as shown in table~\ref{tab:icosubgraphs}
(page~\pageref{tab:icosubgraphs}).


\section{Additional Functions}
\label{sec:AdditionalFunctions}

Besides the main parts of the program, which have been described on the previous
pages, some script-like executable programs are provided. These were used to
calculate various different properties of the investigated clusters and will be
briefly explained in the following.

\paragraph{Analyse Bond Lengths}%app-bondvariance app-shortestbond (app-N14?)
The bond variance in optimised structures can be calculated with
\texttt{app-bondvariance}. The bond variance is simply defined as the difference
between the shortest and longest bond of a cluster structure. In clusters
optimised by soft potentials a bond is not as well defined as for \ac{SHS}
clusters. Therefore, it has to be determined with respect to a user-provided
threshold value and the variance of the bond lengths can not be larger than this
threshold. This application has been used in
chapter~\ref{sec:612LennardJonesClustersfromBasinHopping} to calculate the bond
variance of the optimised $(6,12)$-\ac{LJ} structures. A more specialised
version called \texttt{app-shortestbond} is also provided that can be used to
find the cluster with the shortest bond distance.

\paragraph{Sort Structures by $N_c$}%app-GN and app-Nc

Analysing the total contact numbers $N_c$ or specific kissing numbers can be
done with the programs \texttt{app-Nc} and \texttt{app-GN}. The letter looks
for clusters with a central atom that has exactly 12 spheres arranged around
it, so called Gregory-Newton clusters.

\section{Implementations in Detail}
\label{sec:ImplementationsinDetail}

In the following sections the basic implementation of cluster structures and
two-body potentials will be explained in more detail.

\subsection{Treating Cluster Structures}
\label{sec:thestructureclass}

The main purpose of program \textsc{Spheres} was to optimise an input set of
structures with given Cartesian coordinates and analyse the results of the
optimisation based on properties of the resulting structures. The handling of
those structures and respective properties was therefore crucial to the
function of the program.

The Cartesian coordinates are read from a file and for each individual set of
coordinates a \verb|structure| object is created. The \verb|structure| class,
however, holds much more functionality than storing 3D coordinates. In fact, it
serves as a complex data type storing properties besides coordinates as well as
functions to calculate those properties. Those properties are stored in
variables defined in the private block, such that they can only be manipulated
by functions owned by the \verb|structure| class. Alongside Cartesian
coordinates the \verb|structure| class is designed to hold values for energy
(depending on the chosen potential), an integer number for labelling, moment of
inertia, the \ac{EDM} and adjacency matrix representations and an
\verb|undirectedGraph| that contains the connectivity information.

The Cartesian coordinates are stored in a \verb|std::vector| container, while
each individual sphere is represented by a \verb|coord3d| object. The latter is
a modified version of the \verb|coord3d| implementation used in program
FULLERENE.\autocite{Schwerdtfeger_Programfullerenesoftware_2013} 

The moment of inertia tensor determines the force needed to accelerate a rigid
body to spin around a rotational axis. It is therefore equivalent to mass in
case of linear, translational acceleration. For cluster structures the tensor
is equal to the sum over the moments of inertia of all constituent particles.
As the clusters investigated in this thesis are only made up of one type of
particle the mass term was set to unity. The inertia tensor $\mathbf{I}$ can
then be calculated via the equations below.
%
\begin{align}
    \begin{aligned}
    \mathbf{I}=
    \begin{pmatrix}
        I_{xx} & I_{xy} & I_{xz}\\
        I_{yx} & I_{yy} & I_{yz}\\
        I_{zx} & I_{zy} & I_{zz}
    \end{pmatrix}\\
    I_{xx}=\sum_i(y_i^2+z_i^2) \quad I_{yy}=\sum_i(x_i^2+z_i^2) \quad I_{xx}=\sum_i(y_i^2+x_i^2)\\
    I_{xy} = I_{yx} = -\sum_ix_iy_i \quad I_{xz} = I_{zx} = -\sum_ix_iz_i \quad I_{yz} = I_{zy} = -\sum_iy_iz_i\\
    \end{aligned}
\end{align}
%
Here, $x_i$, $y_i$ and $z_i$ denote the respective coordinate of sphere $i$.
Diagonalising the inertia tensor yields a set of eigenvalues and eigenvectors,
with the latter representing the principal axis system. Upon creation of a
\verb|structure| object the coordinates are transformed, such that the
coordinate origin lies at the centre of mass and the structures principal axis
are aligned with the basis vectors of the Cartesian coordinate system.

The class is designed to ensure the stored coordinates always match the stored
properties.


\subsection{Treating Two-Body Potentials}
\label{sec:thepairpotentialclass}

As shown in
section~\ref{sec:PracticalImplementationForPotentialsDependingOnPairDistances}
the scalar energy part can be completely separated from the vector part. This
was used to implement energy, gradient and Hessian calculations in a generic
way such that the energy function can be exchanged easily. 

For this, a base class called \verb|pairPotential| was defined. Its private
block holds virtual definitions of the functions that calculate energy $E(r)$,
first derivative $\dv*{E}{r}$ and second derivative $\dv*[2]{E}{r}$ based on
particle distance $r$. They are declared virtual, because they will be
overridden with the respective functions in the derived classes of the actual
potentials. In the bare \verb|pairPotential| class those functions are not
returning a meaningful energy. The public block contains the class constructor
as well as the user accessible functions for calculating energy, gradient
vector and Hessian matrix as well as the optimiser.

As an example, the calculation of the energy of a structure as implemented in
the base class is shown in algorithm~\ref{algo:EnergyCalculation}.
%
\begin{algorithm}
    \caption{Energy calculation.}
    \label{algo:EnergyCalculation}
    \begin{algorithmic}[1]
        \Procedure{calculateEnergy}{Structure}
        \ForAll{Unique Pairs of Spheres in Structure}
                \State $E\gets E +$ Energy(Sphere1, Sphere2);\label{algo:virtualEnergy}
        \EndFor
        \State \textbf{return} $E$;
        \EndProcedure
    \end{algorithmic}
\end{algorithm}
%
The procedure takes a \verb|structure| object as input and uses the virtual
energy function to calculate the energy contributions of all pairs of spheres
without double counting in line~\ref{algo:virtualEnergy}.

To define a potential a derived class that overrides the virtual function
definitions needs to be provided. The private block re-defines the previously
declared virtual functions to be non-virtual and a proper definition has to be
given for the potential to work. Additionally, any parameters, that the
potential form depends on, are declared in the private block. In the
public section, constructor functions for the respective potential as well as a
function that reads the potential parameters from a user provided file need to
be declared. The last function is important as it also creates the potential
object on heap memory, which is necessary, because the exact nature of the
potential is not known at compile time. A pseudo-code example for the \ac{LJ}
potential in reduced units with arbitrary exponents $a$ and $b$ is given in
algorithm~\ref{algo:LJEnergyFunction}.
%
\begin{algorithm}
    \caption{Lennard-Jones energy function.}
    \label{algo:LJEnergyFunction}
    \begin{algorithmic}[1]
        \Procedure{Energy}{Sphere1, Sphere2}
            \State $r \gets$ Distance(Sphere1, Sphere2);
            \State $E \gets \frac{1}{b-a}\left[ar^{-b}-br^{-a}\right]$;
            \State \textbf{return} $E$;
        \EndProcedure
    \end{algorithmic}
\end{algorithm}
%
To define a new potential the only line that has to be changed is the third
line containing the evaluation of the \ac{LJ} energy and a method for reading
the parameters for the new potential from an external file has to be
implemented. The function that reads the parameters has to be written such
that its return value is a pointer to an instantiation of that class on the
heap memory. An example for the \ac{LJ} potential is given below.
%
\begin{verbatim}
    LJ *potential = new LJ(epsilon, rm, exp1, exp2);
\end{verbatim}
%
The first line declares the pointer \verb|potential| to be an instantiation of
the \verb|LJ| class and is created by the previously defined constructor
\verb|LJ(epsilon, rm, exp1, exp2)| and the \verb|new| keyword, that ensures the
creation of the pointer on heap memory. Because memory on heap has to be
managed by the user, the pointer is used in conjunction with \verb|unique_ptr|
to ensure destruction of the object upon exiting the scope.

\chapter{Computational Details}
\label{sec:ComputationalDetails}

The following sections detail the methodologies used in part~\ref{sec:results}.
They have been altered slightly from the original
publications\autocite{Trombach_HollowGoldCages_2016,Trombach_stickyhardsphereLennardJonestypeclusters_2018,Trombach_GregoryNewtonproblemkissing_2018}
to match the style of this thesis.

\section[Computational Details for
Chapter~\ref{sec:goldendualfullerenes}]{Computational Details for
Chapter~\ref{sec:goldendualfullerenes}\footnote{This section has been published
previously in
\citetitle*{Trombach_HollowGoldCages_2016}\autocite{Trombach_HollowGoldCages_2016}
and is reproduced with permission from the publisher \textcopyright 2016
WILEY-VCH Verlag GmbH \& Co. KGaA.}}
\label{sec:ComputationalDetailsforGoldenDualFullerenes}

Program FULLERENE\autocite{Schwerdtfeger_Programfullerenesoftware_2013} has
been used to construct initial structures of all isomers of the golden dual
fullerenes from Au$_{12}$ to Au$_{20}$ using a recently developed force-field
for fullerenes\autocite{Wirz_smallfullerenesgraphene_2015} (excluding the
non-existing golden dual fullerene Au$_{13}$). The following isomers need to be
considered according to the isomer list for the fullerenes (number in
parenthesis gives the number of different isomers of same
symmetry):\autocite{Brinkmann_HouseGraphsdatabase_2013,Schwerdtfeger_Programfullerenesoftware_2013}
$I_\mathrm{h}-$Au$_{12}$, $D_\mathrm{6d}-$Au$_{14}$, $D_\mathrm{3h}-$Au$_{15}$,
$D_\mathrm{2}-$Au$_{16}$, $T_\mathrm{d}-$Au$_{16}$, $D_\mathrm{5h}-$Au$_{17}$,
$C_\mathrm{2v}-$Au$_{17}$(2), $D_\mathrm{3h}-$Au$_{18}$,
$D_\mathrm{3d}-$Au$_{18}$, $D_\mathrm{3}-$Au$_{18}$, $D_\mathrm{2}-$Au$_{18}$,
$C_\mathrm{3}-$Au$_{18}$(2), $C_\mathrm{3v}-$Au$_{19}$,
$C_\mathrm{2}-$Au$_{19}$(3), $C_\mathrm{s}-$Au$_{19}$(2),
$D_\mathrm{6h}-$Au$_{20}$, $D_\mathrm{3h}-$Au$_{20}$,
$D_\mathrm{2d}-$Au$_{20}$(2), $C_\mathrm{2v}-$Au$_{20}$,
$D_\mathrm{2}-$Au$_{20}$(2), $C_\mathrm{2}-$Au$_{20}$(3),
$C_\mathrm{2}-$Au$_{20}$(2), $C_\mathrm{1}-$Au$_{20}$(2) and
$I_\mathrm{h}-$Au$_{32}$. The initial force-field optimised structures scaled
to an approximate internuclear distance were then refined by using the
Predew-Burke-Ernzerhof \ac{GGA}
functional\autocite{Perdew_GeneralizedGradientApproximation_1996,Perdew_GeneralizedGradientApproximation_1997}
corrected for dispersion interactions using Grimme's method
(PBE-D3)\autocite{Grimme_consistentaccurateinitio_2010,Grimme_Effectdampingfunction_2011}
together with a Los-Alamos scalar relativistic effective core potential for
gold and the accompanying double-zeta basis sets.\autocite{Wadt1985} Note that
the PBE functional was recently considered to perform well for gold
clusters.\autocite{Mancera_alternativemethodologyassess_2015} For several
selected clusters the geometries obtained were checked for accuracy by carrying
out calculations using a small core scalar relativistic Stuttgart
pseudopotential\autocite{Figgen_Energyconsistentpseudopotentialsgroup_2005}
together with an augmented valence double-zeta basis set by Peterson and
Puzzarini.\autocite{Peterson-2005} For comparison, the compact global minimum
cluster structures recently published for the neutral
compounds\autocite{Assadollahzadeh_systematicsearchminimum_2009} and for the
negatively charged
species\autocite{Schooss_Determiningsizedependentstructure_2010,Lechtken_Structuredeterminationgold_2009}
were calculated.

The simulation of the photoelectron spectra has been carried out by artificial
broadening the spectrum of orbital energies with Gaussian functions. The
standard deviation $\sigma$ for these functions was chosen to be 0.035~eV in
qualitative agreement with the experimental spectra. The orbital energies were
calculated using the PBE density functional with the
def2-SVP\autocite{Weigend_Balancedbasissets_2005} double zeta basis implemented
in TURBOMOLE 7.0.\autocite{_TURBOMOLEV72015_} The core region was described
using an effective core potential including scalar relativistic effects.  The
calculated electron affinities were used as the onset value for simulating the
photoelectron spectra. 


For the calculation of the (111) fcc sheet and the fcc bulk structure of gold
the program package VASP5\autocite{Kresse_Efficiencyabinitiototal_1996} was used,
utilizing a plane-wave basis set (cutoff energy $E_c=350$~eV) and the standard
projector-augmented wave (PAW) datasets for the elements to model the
electron-ion
interaction\autocite{Blochl_Projectoraugmentedwavemethod_1994,Kresse_ultrasoftpseudopotentialsprojector_1999}.
The electron-electron interaction was modelled within the \ac{GGA}to the
exchange-correlation energy functional as described above and dispersive
effects were taken into account by employing Grimme's D3 dispersion correction
with Becke-Johnson
damping.\autocite{Grimme_consistentaccurateinitio_2010,Grimme_Effectdampingfunction_2011}
Brillouin zone integrations were carried out on $\Gamma$-centred Monkhorst-Pack
grids of $k$-points with a distance of 0.2~\AA$^{-1}$. The cohesive energy is
defined as the atomisation energy per atom keeping in mind that one gold atom
is negatively charged for the anionic clusters.

In order to discuss how much the gold cages deviate from sphericity compared to
the dual fullerene structure the previously introduced definition of a \ac{MDS}
was used,\autocite{Schwerdtfeger_Programfullerenesoftware_2013}
%
\begin{equation} 
\min\limits_{c_\mathrm{MDS} \in \mathrm{CH}(S)} \frac{1}{N} \sum _{i} \left|R_\mathrm{MDS} -\| \vec{p}_{i}-\vec{c}_\mathrm{MDS} \| \right|  
\end{equation}
with the \ac{MDS} radius defined as
\begin{equation} 
	R_{\mathrm{MDS}} =\frac{1}{N} \sum _{i}\| \vec{p}_{i} -\vec{c}_{\mathrm{MDS}} \|. 
	\label{eq:RMDS}
\end{equation}
%
Here $S$ is the set of $n$ points $\vec{p}_i$ ($i=1,\ldots ,N$) in
$3$-dimensional space, $\mathrm{CH}(S)$ its convex hull, $\|\cdot\| $ the
Euclidean norm, and $\vec{c}_\mathrm{MDS}$ is the barycentre of the \ac{MDS}
with radius $R_\mathrm{MDS}$. In other words, a sphere approximating the
distance of the vertices to the centre is searched. A measure
for distortion from spherical symmetry through the
\ac{MDS} is defined as\autocite{Schwerdtfeger_Programfullerenesoftware_2013}
%
\begin{equation}
  \label{eq:DMDS}
  D_{\mathrm{MDS}} = \frac{100}{N R_\mathrm{min}} \sum_{i=1}^N \left|R_{\mathrm{MDS}} - \|\vec{p}_i - \vec{c}_{\mathrm{MDS}}\| \right|,
\end{equation}
where $R_\mathrm{min}$ is the smallest bond distance found in the cluster. The pentagon index $N_p$ is defined as
\begin{equation}
  \label{pentindex}
  N_p = \frac{1}{2}\sum_{k=1}^{5} kp_k \quad \text{ with } \quad  \sum_{k=0}^{5} p_k = 12
\end{equation}
%
where the pentagon indices $(p_i | i=0, \dots , 5)$ define the number of
pentagons attached to another pentagon.\autocite{Fowler-atlas-2006}

\section[Computational Details for
Chapter~\ref{sec:fromstickyhardspheretoLJtypeclusters}]{Computational Details
for Chapter~\ref{sec:fromstickyhardspheretoLJtypeclusters}\footnote{This
section has been published previously in
\citetitle*{Trombach_stickyhardsphereLennardJonestypeclusters_2018}\autocite{Trombach_stickyhardsphereLennardJonestypeclusters_2018}
and is reproduced with permission from the publisher \textcopyright 2018
American Physical Society.} }

The \textit{pele} program~\autocite{_pelePythonenergy_2017} was used to generate putatively
complete sets of local minima for $(m,n)$-Lennard-Jones potentials 
$V_{mn}^{\mathrm LJ}(r)$ as defined in equation~\eqref{eqn:nmpot}.
This program  applies a basin-hopping algorithm that divides the potential energy
surface into basins of attraction, effectively mapping each point in
configuration space to a local minimum structure
\autocite{Li_MonteCarlominimizationapproach_1987,waless99,Wales_GlobalOptimizationBasinHopping_1997}.  The results confirmed the
number of local minima reported in previous work \autocite{Doye_Saddlepointsdynamics_2002}.
Finite computer time limited our search to clusters of size $N \leq 13$.

Starting from the sticky hard sphere packings up to $N=14$, with Cartesian
coordinates given by the exact enumeration algorithm
\autocite{Hoy_Structurefinitesphere_2012} including rigid hypostatic clusters
($N_c<3N-6$) \autocite{Holmes-Cerfon_EnumeratingRigidSphere_2016} geometry
optimisations with $(m,n)$-Lennard-Jones potentials using the multidimensional
function minimiser from the \Cpp library \textit{dlib}
\autocite{King_DlibmlMachineLearning_2009} were carried out with the previously
described program package \textsc{Spheres}
(Chapter~\ref{sec:theprogramspheres}). The optimisation scheme was either the
\ac{BFGS} or the conjugate gradient algorithm. The optimisations were terminated when the
change in energy (in reduced units) over the course of one optimizsation cycle
was smaller than $10^{-15}$. 

Subsequently, the eigenvalues of the Hessian were checked
for all stationary points. If negative eigenvalues were found, the affected
structures were reoptimized following displacements in both directions along
the corresponding eigenvectors to locate true local minima. This procedure assures
that the floppy \ac{SHS} packings are successfully mapped into LJ minima.

As the optimisations often result in many duplicates, especially for small
values of $n$ and $m$ where $|\mathcal{M}_{(m,n)\mathrm{-LJ}}| \ll
|\mathcal{M}_\mathrm{SHS}|$, the final structures were further analysed and
sorted. Nonisomorphic \ac{SHS} clusters can be distinguished (apart from
permutation of the particles) by their different adjacency matrices for $N \leq
13$ \autocite{Holmes-Cerfon_EnumeratingRigidSphere_2016}.  This is not the case
for soft potentials like the LJ potential since drawing edges (bonds) between
the vertices (atoms) becomes a matter of defining the distance cutoff criterion
for a bond to be drawn. Therefore, the clusters were compared based on the
\ac{EDM} (the matrix of interparticle distances $\{r_{ij}\}$) as described
previously: two clusters are isomorphic (structurally identical) if they have
the same ordered set of inter-particle distances $\{r_{ij}\}$.  While
enantiomers cannot be separated using this methodology, permutation-inversion
isomers are usually lumped together, since the number of distinct minima is
analytically related to the order of the corresponding point group
\autocite{Wales_Energylandscapes_2003}.  To verify the number of distinct structures we introduced
a second ordering scheme using the energy and moment of inertia tensor
eigenvalues. 

Two sets of structures are obtained from our optimization procedure: the first
set contains all possible LJ minima $\mathcal{M}_\mathrm{LJ}$ from the
basin-hopping algorithm, while the second set $\mathcal{M}_\mathrm{SHS\to LJ}$
contains the LJ minima obtained using only the $\mathcal{M}_\mathrm{SHS}$
sticky-hard-sphere cluster structures as starting points for the geometry
optimization.  To compare and identify corresponding structures between the two
sets, the $N(N-1)/2$ inter-particle distances $\{r_{ij}\}$ were again used as
an identifying fingerprint.

Two-body \ac{eLJ} potentials that accurately model
two-body interactions in rare-gas clusters can be written as expansions of
inverse-power-law terms
\autocite{Schwerdtfeger_ExtensionLennardJonespotential_2006}:
%
\begin{equation} \label{eq:ELJ}
V_{\mathrm ELJ}(r)=\sum_{n} c_nr^{-n},
\end{equation}
%
where in reduced units the condition $\sum_{n} c_n=-1$ holds. For comparison
to the simple (6,12)-\ac{LJ} potential, the \ac{eLJ} potential derived from
relativistic coupled-cluster theory applied to the xenon dimer was used with the
following coefficients (in reduced units):
$c_6=-1.0760222355$; $c_8=-1.4078314494$; $c_9=-185.6149933139$;
$c_{10}=+1951.8264493941$; $c_{11}=-8734.2286559729$;
$c_{12}=+22273.3203327203$; $c_{13}=-35826.8689874832$;
$c_{14}=+37676.9744744424$; $c_{15}=-25859.2842295062$;
$c_{16}=+11157.4331408911$; $c_{17}=-2745.9740079192$; $c_{18}=+293.9003309498$
\autocite{Jerabek_relativisticcoupledclusterinteraction_2017}. The \ac{eLJ}
potential for xenon is shown in figure~\ref{fig:LJ} (dashed line).

\section[Computational Details for
Chapter~\ref{sec:thegregorynewtonclusters}]{Computational Details for
Chapter~\ref{sec:thegregorynewtonclusters}\footnote{This section has been
published previously in
\citetitle*{Trombach_GregoryNewtonproblemkissing_2018}\autocite{Trombach_GregoryNewtonproblemkissing_2018}
and is reproduced with permission from the publisher \textcopyright 2018
American Physical Society.}}

Coordinates for \ac{GNC} structures have been obtained by searching for
adjacency matrices of the results for $N=13$ from
\citeauthor{Holmes-Cerfon_EnumeratingRigidSphere_2016}
\autocite{Holmes-Cerfon_EnumeratingRigidSphere_2016} with one row or column
containing twelve ``1'' entries. Sub-graph isomorphism was verified using the
\textit{VF2} algorithm \autocite{Cordella_SubGraphIsomorphism_2004} as
implemented in the \textit{boost graph library}
\autocite{Siek_BoostGraphLibrary_2002} using the program package
\textsc{Spheres}. Structural optimisations with \ac{LJ} potentials have been carried
out using the multidimensional function minimiser from the \Cpp library
\textit{dlib} \autocite{King_DlibmlMachineLearning_2009} and an energy
convergence criterion of $10^{-15}$. Results from the optimisation procedure
were analysed based on the \ac{EDM}, which is unique for
non-isomorphic structures apart from permutation, translation, rotation and
inversion. For this the distances were sorted lexicographically.
