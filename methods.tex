%methods

\part{Methods}
\label{sec:methods}

\chapter{Quantum Chemical Programs}
\label{sec:quantumchemicalprograms}

\chapter{Program \textsc{Spheres}}
\label{sec:theprogramspheres}

On the following pages the program package \textsc{Spheres} will be explained
in detail. The projects in
chapters~\ref{sec:fromstickyhardspheretoLJtypeclusters} and
\ref{sec:thegregorynewtonclusters} required routines to optimise given starting
cluster geometries and analyse the results. The optimisation routine needed to
be flexible in the way that it would be easy to implement different two-body
potentials like \ac{LJ} or \ac{eLJ}. The program was written in \Cpp
and was tested to compile in a Linux environment with the \texttt{clang++}
compiler version 3.8.

\section{Structural Optimisation and Analysis}
\label{sec:generalstructure}

The main functions of the program are implemented in three different
executable programs. Each carries out a different task, i.e optimising given input
structures and output the results, removing duplicate structures from a set of
input structures and finding differences of two sets of input structures. The
respective output of these programs is set up such that they can be used as
input files for the other executable programs. This allows the programs to be used
consecutively while retaining the flexibility of using each executable program
separately. This chain-like execution is depicted in
figure~\ref{fig:OptimisationAnalyseScheme}. 
%
\begin{figure}[htb]\centering
    \begin{tikzpicture}[node distance = 3cm, scale=0.8, auto, transform shape]%, every node/.style={scale=0.8}]
    \node [cloud] (Input1) {Input structures};
    \node [block, right of=Input1] (Optimise) {Optimise};
    \node [decision, right of=Optimise] (Hessian) {Negative values in Hessian?};
    \node [block, below of=Optimise] (reopt) {Displace geometry};
    \node [cloud, right=1.5cm of Hessian] (print) {Optimised Structures};
    \node [block, below of=print] (Analyse) {Analyse $\{r_{ij}\}$};
    \node [cloud, below of=Analyse] (Analysed) {Duplicates removed};
    \node [block, left of=Analysed] (Match) {Match sets};
    \node [cloud, left of=Match] (Input2) {Input structures};
    \node [cloud, below of=Match] (missing) {Missing clusters};

    \path [line] (Input1) -- (Optimise);
    \path [line] (Optimise) -- (Hessian);
    \path [line] (Hessian) |- node {yes} (reopt);
    \path [line] (reopt) -- (Optimise);
    \path [line] (Hessian) -- node {no} (print);
    \path [line] (print) -- (Analyse);
    \path [line] (Analyse) -- (Analysed);
    \path [line] (Analysed) -- (Match);
    \path [line] (Input2) -- (Match);
    \path [line] (Match) -- (missing);

    \node (OptProg) [transform shape=false,draw, color=blue, dashed, thick, %
        fit=(Optimise) (Hessian) (reopt)] {};
    %\node [above=0.1cm of OptProg] {\texttt{Optimize}};

    \node (InputBox1) [draw,color=gray,thick,transform shape=false, fit=(Input1)] {}; 
    \node (InputBox2) [draw,color=gray,thick,transform shape=false, fit=(Input2)] {}; 
    \node (OutputBox1) [draw,color=gray,thick,dashed,transform shape=false, fit=(print)] {}; 
    \node (OutputBox2) [draw,color=gray,thick,dashed,transform shape=false, fit=(Analysed)] {}; 
    \node (OutputBox3) [draw,color=gray,thick,dashed,transform shape=false, fit=(missing)] {}; 
    \node [above=0.1cm of InputBox1] {Input 1};
    \node [below=0.1cm of InputBox2] {Input 2};
    \node [above=0.1cm of OutputBox1] {Output 1};
    \node [below=0.1cm of OutputBox2] {Output 2};
    \node [below=0.1cm of OutputBox3] {Output 3};

\end{tikzpicture}
    \caption{Schematic representation of the optimisation, analysis and
    matching procedure. Red circles: program input or output, blue squares:
    program functions.}
    \label{fig:OptimisationAnalyseScheme}
\end{figure}
%
A set of input structures (Input 1) is provided to the first executable program
\texttt{optimize}, which optimises the structures and generates Output 1, which
is a list of optimised coordinates in the same format as the input. This can be
used as input for the second executable program \texttt{analyze}, which uses
the distance matrix to identify duplicate structures and outputs a list of
optimised structures with no duplicates (Output 2). In combination with a
secondary set of structures (Input 2) the third executable program
\texttt{match} can be used to compare both sets of structures and output
coordinates of structures that are missing from either set 1 or 2 (Output 3). 

\subsection{Optimisation of Input Structures}
\label{sec:optimisationofinputstructures}

The optimisation of input structures with a chosen potential can be carried out
with the program \texttt{optimize}. The coordinates of the input structures
have to be provided in a single file where each line contains three numbers
representing the position of on sphere. Multiple structures can be included by
separating the list of coordinates by single blank lines. The program
automatically moves the input structures to their respective centres of mass,
and rotates them into the principal axis system. To speed up the optimisation
the Unix variable \texttt{OMP\_NUM\_THREADS} can be set to a value
greater than one to enable \ac{OMP} parallelisation.

The optimisation can be controlled by parameters set in the \texttt{settings}
file using the \texttt{opt} keyword. The form of the optimisation potential can
be chosen with the \texttt{name} tag, which currently can be set to either
\texttt{BFGS} for the \ac{BFGS} algorithm or \texttt{CG} for the conjugate
gradient method. The energy termination criterion is defined using the
\texttt{dforce} tag.Furthermore, the maximum number of steps can be set with
the \texttt{nsteps} tag. An example is given in the box below.
\newline
\begin{Verbatim}[frame=single,label=settings file - opt tag]
opt: {
    name = "BFGS";
    dforce = 1e-10;
    nsteps = 100;
};
\end{Verbatim}
%
A potential model has to be chosen for the optimisation procedure. Custom
models can be defined easily, which will be explained later. The current
implementation allows the selection of two pair potentials, namely \ac{LJ} and
\ac{eLJ}. For the \ac{LJ} potential four parameters have to be given to the
\texttt{potential} tag as seen in the box below.
%
\begin{Verbatim}[frame=single,label=settings file - potential tag]
potential: {
    name = "LJ";
    epsilon = 1.0;
    rm =  1.0;
    exp1 = 12.0;
    exp2 = 6.0;
};
\end{Verbatim}
%
The \texttt{name} tag enables the \ac{LJ} potential to be used and the four
parameters \texttt{epsilon}, \texttt{rm}, \texttt{exp1} and \texttt{exp2}
define the potential. The values shown in the example are the default values,
which the program will fall back to if no values are provided by the user. The
\ac{eLJ} potential can be chosen by setting the \texttt{name} tag to
\texttt{ELJ}. The $c_n$ coefficients have to be provided in a separate file
named \texttt{ext}, where each line contains two numbers. The first integer
represents $n$ and the second floating point number defines the corresponding
coefficient.

After each structural optimisation the program checks if the structure is a
true minimum by calculation the Hessian matrix eigenvalues. If this check fails
the eigenvectors of the Hessian matrix are calculated and the non-minimum
structure is displaced according to eigenvector belonging to the first negative
eigenvalue in the Hessian matrix. The algorithm tries to re-optimise until
there are no negative eigenvalues in the Hessian matrix or until a maximum
number of five re-optimisations is reached.

The resulting structures are printed in the file \verb|coord| in the same
format as the input. To analyse the optimisation procedure the additional files
\verb|opt| and \verb|reopt| are printed, which contain the intermediate steps
of the optimisation and re-optimisation procedures for each individual input
structure.

\subsection{Removing Duplicate Structures}
\label{sec:analysingresults}

Duplicated geometries in a set of input structures can be identified using the
second sub-program \texttt{analyze}. The input has to be provided in the same
format as for the \texttt{optimize} program. The read-in procedure is
equivalent to the on in the \texttt{optimize} program. The program uses two
methods to identify unique structures, one of which uses the energy of the
cluster as a criterion, therefore the \texttt{potential} tag has to be set in
the \texttt{settings} file.

The first method uses four values to uniquely identify a structure. Those are
the values for energy and the three eigenvalues of the moment of inertia
tensor. This sorting procedure uses a \verb|map| container, which is an
implementation of a binary search tree. This allows the algorithm to scale well
with the number of structures to be analysed. The \verb|map| container contains a
\verb|key| and a \verb|value| field and elements of a \verb|map| are guaranteed
to be stored in order.\autocite{Stroustrup_programminglanguage_2000} In this
specific case the ordering is done by energy first, then smallest moment of
inertia tensor eigenvalue followed by the two other moment of inertia tensor
eigenvalues. The \texttt{map} container maps the \texttt{key}, which is the
combination of energy and moment of inertia eigenvalues, to a \texttt{value},
which is simply the number of structures in this case. 

The advantage of this method is its great scalability with respect to the
number of input structures as values can be retrieved quickly based on the
key.

The second method uses the \ac{EDM} as the differentiation criterion. The
\ac{EDM} is the matrix of all inter-particle distances $d_{ij}$ where each
entry is defined as the Euclidean norm $||\cdot||$ between to spheres.
%
\begin{align}
    d_{ij}=||\mathbf{x}_i-\mathbf{x}_j||^2
\end{align}
%
The \ac{EDM} represents a unique embedding of the cluster in space, however
information about the absolute position and orientation are lost on creation.
That means rigid transformations of clusters (translations, rotations,
reflections) don't affect the \ac{EDM} as they don't change fixed distances
between points in space.\autocite{Dokmanic_EuclideanDistanceMatrices_2015} If
at least one inter-particle distance is different two structures are said to be
not equal. The algorithm is implemented such that a structure's distance matrix
is compared to the distance matrix of all other already sorted structures and
is added to the matching group if they are equal up to a set threshold. If not,
the structure is added to the array as a new group. The more unique structures
the optimisation produced the slower this method of sorting becomes, as each
trial structure has to be compared to all other already sorted structure
groups.

\subsection{Matching Structures}
\label{sec:matchingstructures}

To compare the results from the optimisations procedures to previously
published sets of clusters the program \verb|match| can be used. It takes two
files as input that each contain a set of structures of equal of different size
and compares them based on the \ac{EDM}. The number of atoms in each set must
be equal, otherwise the program will be terminated. If both sets are found to
be identical no output files are created. In case there are unmatched
structures they will be printed in \verb|xyz| format in the \verb|output|
directory for further analysis.

\section{Graph-Theoretical Analysis}
\label{sec:GraphTheoreticalAnalysis}



\section{Additional Functions}
\label{sec:AdditionalFunctions}

Besides the main parts of the program that have been described on the previous
pages some script-like executable programs are provided. These were used to calculate
various different properties of the investigated clusters and will be briefly
explained in the following.

\paragraph{Analyse Bond Lengths}%app-bondvariance app-shortestbond (app-N14?)
The bond variance in optimised structures can be calculated with
\texttt{app-bondvariance}. The bond variance is simply defined as the
difference between the shortest and longest bond of a cluster structure. In
clusters optimised by soft potentials a bond is not as well defined as for a
\ac{SHS} cluster. Therefore, it has to be determined by a user-provided
threshold value and the variance of the bond lengths can not be larger than
this threshold. This application has been used in
chapter~\ref{sec:612LennardJonesClustersfromBasinHopping} to calculate the bond
variance of the optimised $(6,12)$-\ac{LJ} structures. A more specialised
version called \texttt{app-shortestbond} is also provided that can be used to
find the cluster with the shortest bond distance.

\paragraph{Sort Structures by $N_c$}%app-GN and app-Nc

Analysing the total contact numbers $N_c$ or specific kissing numbers can be
done with the programs \texttt{app-Nc} and \texttt{app-GN}. The letter looks
for clusters with a central atom that has exactly 12 spheres arranged around
it, so called Gregory-Newton clusters.



\section{Implementations in Detail}
\label{sec:ImplementationsinDetail}

In the following sections some of the more important implementations will be
explained in detail.

\subsection{Treating Cluster Structures}
\label{sec:thestructureclass}

The \verb|structure| class provides methods to store coordinates of cluster
geometries and holds functions to calculate properties like energy and moment
of inertia and store them together with the coordinates in the same object. The
class relies on the \verb|coord3d| class for the storage of the coordinates of
the individual spheres.  When an object of this class is created by providing a
set of Cartesian coordinates the center of the structure will be moved to the
center of mass of the system and the structure will be rotated such that the
main axis align with the principal axis of the structure. Additionally, all
inter-particle distances will be calculated and stored in the object so that
they are readily available for analysis.

For graph theoretical analysis the class provides functions to calculate
adjacency matrices and graphs based on methods implemented in the \textit{boost
graph library}\autocite{Siek_BoostGraphLibrary_2002}. These methods take a threshold number
that defines the distance between two spheres at which they are considered
connected.

\subsection{Treating Two-Body Potentials}
\label{sec:thepairpotentialclass}

As shown in
section~\ref{sec:PracticalImplementationForPotentialsDependingOnPairDistances}
the scalar energy part can be completely separated from the vector part. This
was used to implement energy, gradient and Hessian calculations in a generic
way such that the energy function can be exchanged easily.

