%methods

\part{Methods}
\label{sec:methods}

\chapter{Program \textsc{Spheres}}
\label{sec:theprogramspheres}

On the following pages the program package \textsc{Spheres} will be explained
in detail. The projects in
chapters~\ref{sec:fromstickyhardspheretoLJtypeclusters} and
\ref{sec:thegregorynewtonclusters} required routines to optimise given starting
cluster geometries and analyse the results. The optimisation routine needed to
be flexible in the way that it would be easy to implement different two-body
potentials like \ac{LJ} or \ac{eLJ}. The program was written in \Cpp
and was tested to compile in a Linux environment with the \texttt{clang++}
compiler version 3.8.

\section{Structural Optimisation and Analysis}
\label{sec:generalstructure}

The main functions of the program are implemented in three different
executable programs. Each carries out a different task, i.e optimising given input
structures and output the results, removing duplicate structures from a set of
input structures and finding differences of two sets of input structures. The
respective output of these programs is set up such that they can be used as
input files for the other executable programs. This allows the programs to be used
consecutively while retaining the flexibility of using each executable program
separately. This chain-like execution is depicted in
figure~\ref{fig:OptimisationAnalyseScheme}. 
%
\begin{figure}[htb]\centering
    \begin{tikzpicture}[node distance = 3cm, scale=0.8, auto, transform shape]%, every node/.style={scale=0.8}]
    \node [cloud] (Input1) {Input structures};
    \node [block, right of=Input1] (Optimise) {Optimise};
    \node [decision, right of=Optimise] (Hessian) {Negative values in Hessian?};
    \node [block, below of=Optimise] (reopt) {Displace geometry};
    \node [cloud, right=1.5cm of Hessian] (print) {Optimised Structures};
    \node [block, below of=print] (Analyse) {Analyse $\{r_{ij}\}$};
    \node [cloud, below of=Analyse] (Analysed) {Duplicates removed};
    \node [block, left of=Analysed] (Match) {Match sets};
    \node [cloud, left of=Match] (Input2) {Input structures};
    \node [cloud, below of=Match] (missing) {Missing clusters};

    \path [line] (Input1) -- (Optimise);
    \path [line] (Optimise) -- (Hessian);
    \path [line] (Hessian) |- node {yes} (reopt);
    \path [line] (reopt) -- (Optimise);
    \path [line] (Hessian) -- node {no} (print);
    \path [line] (print) -- (Analyse);
    \path [line] (Analyse) -- (Analysed);
    \path [line] (Analysed) -- (Match);
    \path [line] (Input2) -- (Match);
    \path [line] (Match) -- (missing);

    \node (OptProg) [transform shape=false,draw, color=blue, dashed, thick, %
        fit=(Optimise) (Hessian) (reopt)] {};
    %\node [above=0.1cm of OptProg] {\texttt{Optimize}};

    \node (InputBox1) [draw,color=gray,thick,transform shape=false, fit=(Input1)] {}; 
    \node (InputBox2) [draw,color=gray,thick,transform shape=false, fit=(Input2)] {}; 
    \node (OutputBox1) [draw,color=gray,thick,dashed,transform shape=false, fit=(print)] {}; 
    \node (OutputBox2) [draw,color=gray,thick,dashed,transform shape=false, fit=(Analysed)] {}; 
    \node (OutputBox3) [draw,color=gray,thick,dashed,transform shape=false, fit=(missing)] {}; 
    \node [above=0.1cm of InputBox1] {Input 1};
    \node [below=0.1cm of InputBox2] {Input 2};
    \node [above=0.1cm of OutputBox1] {Output 1};
    \node [below=0.1cm of OutputBox2] {Output 2};
    \node [below=0.1cm of OutputBox3] {Output 3};

\end{tikzpicture}
    \caption{Schematic representation of the optimisation, analysis and
    matching procedure. Red circles: program input or output, blue squares:
    program functions.}
    \label{fig:OptimisationAnalyseScheme}
\end{figure}
%
A set of input structures (Input 1) is provided to the first executable program
\texttt{optimize}, which optimises the structures and generates Output 1, which
is a list of optimised coordinates in the same format as the input. This can be
used as input for the second executable program \texttt{analyze}, which uses
the distance matrix to identify duplicate structures and outputs a list of
optimised structures with no duplicates (Output 2). In combination with a
secondary set of structures (Input 2) the third executable program
\texttt{match} can be used to compare both sets of structures and output
coordinates of structures that are missing from either set 1 or 2 (Output 3). 

\subsection{Optimisation of Input Structures}
\label{sec:optimisationofinputstructures}

The optimisation of input structures with a chosen potential can be carried out
with the program \texttt{optimize}. The coordinates of the input structures
have to be provided in a single file where each line contains three numbers
representing the position of on sphere. Multiple structures can be included by
separating the list of coordinates by single blank lines. The program
automatically moves the input structures to their respective centres of mass,
and rotates them into the principal axis system. To speed up the optimisation
the Unix variable \texttt{OMP\_NUM\_THREADS} can be set to a value
greater than one to enable \ac{OMP} parallelisation.

The optimisation can be controlled by parameters set in the \texttt{settings}
file using the \texttt{opt} keyword. The form of the optimisation potential can
be chosen with the \texttt{name} tag, which currently can be set to either
\texttt{BFGS} for the \ac{BFGS} algorithm or \texttt{CG} for the conjugate
gradient method. The energy termination criterion is defined using the
\texttt{dforce} tag.Furthermore, the maximum number of steps can be set with
the \texttt{nsteps} tag. An example is given in the box below.
\newline
\begin{Verbatim}[frame=single,label=settings file - opt tag]
opt: {
    name = "BFGS";
    dforce = 1e-10;
    nsteps = 100;
};
\end{Verbatim}
%
A potential model has to be chosen for the optimisation procedure. Custom
models can be defined easily, which will be explained later. The current
implementation allows the selection of two pair potentials, namely \ac{LJ} and
\ac{eLJ}. For the \ac{LJ} potential four parameters have to be given to the
\texttt{potential} tag as seen in the box below.
%
\begin{Verbatim}[frame=single,label=settings file - potential tag]
potential: {
    name = "LJ";
    epsilon = 1.0;
    rm =  1.0;
    exp1 = 12.0;
    exp2 = 6.0;
};
\end{Verbatim}
%
The \texttt{name} tag enables the \ac{LJ} potential to be used and the four
parameters \texttt{epsilon}, \texttt{rm}, \texttt{exp1} and \texttt{exp2}
define the potential. The values shown in the example are the default values,
which the program will fall back to if no values are provided by the user. The
\ac{eLJ} potential can be chosen by setting the \texttt{name} tag to
\texttt{ELJ}. The $c_n$ coefficients have to be provided in a separate file
named \texttt{ext}, where each line contains two numbers. The first integer
represents $n$ and the second floating point number defines the corresponding
coefficient.

After each structural optimisation the program checks if the structure is a
true minimum by calculation the Hessian matrix eigenvalues. If this check fails
the eigenvectors of the Hessian matrix are calculated and the non-minimum
structure is displaced according to eigenvector belonging to the first negative
eigenvalue in the Hessian matrix. The algorithm tries to re-optimise until
there are no negative eigenvalues in the Hessian matrix or until a maximum
number of five re-optimisations is reached.

The resulting structures are printed in the file \verb|coord| in the same
format as the input. To analyse the optimisation procedure the additional files
\verb|opt| and \verb|reopt| are printed, which contain the intermediate steps
of the optimisation and re-optimisation procedures for each individual input
structure.

\subsection{Removing Duplicate Structures}
\label{sec:analysingresults}

Duplicated geometries in a set of input structures can be identified using the
second sub-program \texttt{analyze}. The input has to be provided in the same
format as for the \texttt{optimize} program. The read-in procedure is
equivalent to the on in the \texttt{optimize} program. The program uses two
methods to identify unique structures, one of which uses the energy of the
cluster as a criterion, therefore the \texttt{potential} tag has to be set in
the \texttt{settings} file.

The first method uses four values to uniquely identify a structure. Those are
the values for energy and the three eigenvalues of the moment of inertia
tensor. This sorting procedure uses a \verb|map| container, which is an
implementation of a binary search tree. This allows the algorithm to scale well
with the number of structures to be analysed. The \verb|map| container contains a
\verb|key| and a \verb|value| field and elements of a \verb|map| are guaranteed
to be stored in order.\autocite{Stroustrup_programminglanguage_2000} In this
specific case the ordering is done by energy first, then smallest moment of
inertia tensor eigenvalue followed by the two other moment of inertia tensor
eigenvalues. The \texttt{map} container maps the \texttt{key}, which is the
combination of energy and moment of inertia eigenvalues, to a \texttt{value},
which is simply the number of structures in this case. 

The advantage of this method is its great scalability with respect to the
number of input structures as values can be retrieved quickly based on the
key.

The second method uses the \ac{EDM} as the differentiation criterion. The
\ac{EDM} is the matrix of all inter-particle distances $d_{ij}$ where each
entry is defined as the Euclidean norm $||\cdot||$ between to spheres.
%
\begin{align}
    d_{ij}=||\mathbf{x}_i-\mathbf{x}_j||^2
\end{align}
%
The \ac{EDM} represents a unique embedding of the cluster in space, however
information about the absolute position and orientation are lost on creation.
That means rigid transformations of clusters (translations, rotations,
reflections) don't affect the \ac{EDM} as they don't change fixed distances
between points in space.\autocite{Dokmanic_EuclideanDistanceMatrices_2015} If
at least one inter-particle distance is different two structures are said to be
not equal. The algorithm is implemented such that a structure's distance matrix
is compared to the distance matrix of all other already sorted structures and
is added to the matching group if they are equal up to a set threshold. If not,
the structure is added to the array as a new group. The more unique structures
the optimisation produced the slower this method of sorting becomes, as each
trial structure has to be compared to all other already sorted structure
groups.

\subsection{Matching Structures}
\label{sec:matchingstructures}

To compare the results from the optimisations procedures to previously
published sets of clusters the program \verb|match| can be used. It takes two
files as input that each contain a set of structures of equal of different size
and compares them based on the \ac{EDM}. The number of atoms in each set must
be equal, otherwise the program will be terminated. If both sets are found to
be identical no output files are created. In case there are unmatched
structures they will be printed in \verb|xyz| format in the \verb|output|
directory for further analysis.

\section{Graph-Theoretical Analysis}
\label{sec:GraphTheoreticalAnalysis}



\section{Additional Functions}
\label{sec:AdditionalFunctions}

Besides the main parts of the program that have been described on the previous
pages some script-like executable programs are provided. These were used to calculate
various different properties of the investigated clusters and will be briefly
explained in the following.

\paragraph{Analyse Bond Lengths}%app-bondvariance app-shortestbond (app-N14?)
The bond variance in optimised structures can be calculated with
\texttt{app-bondvariance}. The bond variance is simply defined as the
difference between the shortest and longest bond of a cluster structure. In
clusters optimised by soft potentials a bond is not as well defined as for a
\ac{SHS} cluster. Therefore, it has to be determined by a user-provided
threshold value and the variance of the bond lengths can not be larger than
this threshold. This application has been used in
chapter~\ref{sec:612LennardJonesClustersfromBasinHopping} to calculate the bond
variance of the optimised $(6,12)$-\ac{LJ} structures. A more specialised
version called \texttt{app-shortestbond} is also provided that can be used to
find the cluster with the shortest bond distance.

\paragraph{Sort Structures by $N_c$}%app-GN and app-Nc

Analysing the total contact numbers $N_c$ or specific kissing numbers can be
done with the programs \texttt{app-Nc} and \texttt{app-GN}. The letter looks
for clusters with a central atom that has exactly 12 spheres arranged around
it, so called Gregory-Newton clusters.



\section{Implementations in Detail}
\label{sec:ImplementationsinDetail}

In the following sections some of the more important implementations will be
explained in detail.

\subsection{Treating Cluster Structures}
\label{sec:thestructureclass}

The \verb|structure| class provides methods to store coordinates of cluster
geometries and holds functions to calculate properties like energy and moment
of inertia and store them together with the coordinates in the same object. The
class relies on the \verb|coord3d| class for the storage of the coordinates of
the individual spheres.  When an object of this class is created by providing a
set of Cartesian coordinates the center of the structure will be moved to the
center of mass of the system and the structure will be rotated such that the
main axis align with the principal axis of the structure. Additionally, all
inter-particle distances will be calculated and stored in the object so that
they are readily available for analysis.

For graph theoretical analysis the class provides functions to calculate
adjacency matrices and graphs based on methods implemented in the \textit{boost
graph library}\autocite{Siek_BoostGraphLibrary_2002}. These methods take a threshold number
that defines the distance between two spheres at which they are considered
connected.

\subsection{Treating Two-Body Potentials}
\label{sec:thepairpotentialclass}

As shown in
section~\ref{sec:PracticalImplementationForPotentialsDependingOnPairDistances}
the scalar energy part can be completely separated from the vector part. This
was used to implement energy, gradient and Hessian calculations in a generic
way such that the energy function can be exchanged easily. 

For this, a base class called \verb|pairPotential| was defined. Its private
section holds virtual definitions of the functions that calculate energy, first
and second derivative of the energy. They are virtual, because they will be
overridden with the respective functions in the derived classes of the actual
potentials. The public block contains the class constructor as well as the user
accessible functions for calculating energy, gradient vector and Hessian matrix
as well as the optimiser.

As an example, the calculation of the energy of a structure as implemented in
the base class is shown in algorithm~\ref{algo:EnergyCalculation}.
%
\begin{algorithm}
    \caption{Energy calculation.}
    \label{algo:EnergyCalculation}
    \begin{algorithmic}[1]
        \Procedure{calculateEnergy}{Structure}
        \ForAll{Unique Pairs of Spheres in Structure}
                \State $E\gets E +$ Energy(Sphere1, Sphere2);\label{algo:virtualEnergy}
        \EndFor
        \State \textbf{return} $E$;
        \EndProcedure
    \end{algorithmic}
\end{algorithm}
%
The procedure takes a \verb|structure| object as input and uses the virtual
energy function to calculate the energy contributions of all pairs of spheres
without double counting in line~\ref{algo:virtualEnergy}. In the declaration of
the base class the energy function is a dummy function that doesn't actually
calculate any meaningful energy. Only after a proper potential has been defined
the return value of this procedure will be useful.

To define a potential a derived class that overrides the virtual function
definitions needs to be provided. The private block re-defines the previously
declared virtual functions to be non-virtual and a proper definition has to be
given for the potential to function. Additionally, any parameters that the
potential form depends on should be declared in the private block. In the
public section constructor functions for the respective potential as well as a
function that reads the potentials parameters from a user provided file need to
be declared. The last function is important as it also creates the potential
object on heap memory, which is necessary, because the exact nature of the
potential is not known at compile time. A pseudo-code example for the \ac{LJ}
potential in reduced units with arbitrary exponents $a$ and $b$ is given in
algorithm~\ref{algo:LJEnergyFunction}.
%
\begin{algorithm}
    \caption{Lennard-Jones energy function.}
    \label{algo:LJEnergyFunction}
    \begin{algorithmic}[1]
        \Procedure{Energy}{Sphere1, Sphere2}
            \State $r \gets$ Distance(Sphere1, Sphere2);
            \State $E \gets \frac{1}{b-a}\left[ar^{-b}-br^{-a}\right]$;
            \State \textbf{return} $E$;
        \EndProcedure
    \end{algorithmic}
\end{algorithm}
%
To define a new potential the only line that has to be changed is the third
line containing the evaluation of the \ac{LJ} energy and a method for reading
the parameters for the new potential from an external file.

\chapter{Computational Details}
\label{sec:ComputationalDetails}

The following sections detail the methodologies used in part~\ref{sec:results}.
They have been altered slightly from the original
publications\autocite{Trombach_HollowGoldCages_2016,Trombach_stickyhardsphereLennardJonestypeclusters_2018,Trombach_GregoryNewtonproblemkissing_2018}
to match the style of this thesis.

\section{Computational Details for Chapter~\ref{sec:goldendualfullerenes}}
\label{sec:ComputationalDetailsforGoldenDualFullerenes}

Program FULLERENE\autocite{Schwerdtfeger_Programfullerenesoftware_2013} has
been used to construct initial structures of all isomers of the golden dual
fullerenes from Au$_{12}$ to Au$_{20}$ using a recently developed force-field
for fullerenes\autocite{Wirz_smallfullerenesgraphene_2015} (excluding the
non-existing golden dual fullerene Au$_{13}$). The following isomers need to be
considered according to the isomer list for the fullerenes (number in
parenthesis gives the number of different isomers of same
symmetry):\autocite{Brinkmann_HouseGraphsdatabase_2013,Schwerdtfeger_Programfullerenesoftware_2013}
$I_\mathrm{h}-$Au$_{12}$, $D_\mathrm{6d}-$Au$_{14}$, $D_\mathrm{3h}-$Au$_{15}$,
$D_\mathrm{2}-$Au$_{16}$, $T_\mathrm{d}-$Au$_{16}$, $D_\mathrm{5h}-$Au$_{17}$,
$C_\mathrm{2v}-$Au$_{17}$(2), $D_\mathrm{3h}-$Au$_{18}$,
$D_\mathrm{3d}-$Au$_{18}$, $D_\mathrm{3}-$Au$_{18}$, $D_\mathrm{2}-$Au$_{18}$,
$C_\mathrm{3}-$Au$_{18}$(2), $C_\mathrm{3v}-$Au$_{19}$,
$C_\mathrm{2}-$Au$_{19}$(3), $C_\mathrm{s}-$Au$_{19}$(2),
$D_\mathrm{6h}-$Au$_{20}$, $D_\mathrm{3h}-$Au$_{20}$,
$D_\mathrm{2d}-$Au$_{20}$(2), $C_\mathrm{2v}-$Au$_{20}$,
$D_\mathrm{2}-$Au$_{20}$(2), $C_\mathrm{2}-$Au$_{20}$(3),
$C_\mathrm{2}-$Au$_{20}$(2), $C_\mathrm{1}-$Au$_{20}$(2) and
$I_\mathrm{h}-$Au$_{32}$. The initial force-field optimised structures scaled
to an approximate internuclear distance were then refined by using the
Predew-Burke-Ernzerhof \ac{GGA}
functional\autocite{Perdew_GeneralizedGradientApproximation_1996,Perdew_GeneralizedGradientApproximation_1997}
corrected for dispersion interactions using Grimme's method
(PBE-D3)\autocite{Grimme_consistentaccurateinitio_2010,Grimme_Effectdampingfunction_2011}
together with a Los-Alamos scalar relativistic effective core potential for
gold and the accompanying double-zeta basis sets.\autocite{Wadt1985} Note that
the PBE functional was recently considered to perform well for gold
clusters.\autocite{Mancera_alternativemethodologyassess_2015} For several
selected clusters the geometries obtained were checked for accuracy by carrying
out calculations using a small core scalar relativistic Stuttgart
pseudopotential\autocite{Figgen_Energyconsistentpseudopotentialsgroup_2005}
together with an augmented valence double-zeta basis set by Peterson and
Puzzarini.\autocite{Peterson-2005} For comparison, the compact global minimum
cluster structures recently published for the neutral
compounds\autocite{Assadollahzadeh_systematicsearchminimum_2009} and for the
negatively charged
species\autocite{Schooss_Determiningsizedependentstructure_2010,Lechtken_Structuredeterminationgold_2009}
were calculated.

The simulation of the photoelectron spectra has been carried out by artificial
broadening the spectrum of orbital energies with Gaussian functions. The
standard deviation $\sigma$ for these functions was chosen to be 0.035~eV in
qualitative agreement with the experimental spectra. The orbital energies were
calculated using the PBE density functional with the
def2-SVP\autocite{Weigend_Balancedbasissets_2005} double zeta basis implemented
in TURBOMOLE 7.0.\autocite{_TURBOMOLEV72015_} The core region was described
using an effective core potential including scalar relativistic effects.  The
calculated electron affinities were used as the onset value for simulating the
photoelectron spectra. 


For the calculation of the (111) fcc sheet and the fcc bulk structure of gold
the program package VASP5\autocite{Kresse_Efficiencyabinitiototal_1996} was used,
utilizing a plane-wave basis set (cutoff energy $E_c=350$~eV) and the standard
projector-augmented wave (PAW) datasets for the elements to model the
electron-ion
interaction\autocite{Blochl_Projectoraugmentedwavemethod_1994,Kresse_ultrasoftpseudopotentialsprojector_1999}.
The electron-electron interaction was modelled within the \ac{GGA}to the
exchange-correlation energy functional as described above and dispersive
effects were taken into account by employing Grimme's D3 dispersion correction
with Becke-Johnson
damping.\autocite{Grimme_consistentaccurateinitio_2010,Grimme_Effectdampingfunction_2011}
Brillouin zone integrations were carried out on $\Gamma$-centred Monkhorst-Pack
grids of $k$-points with a distance of 0.2~\AA$^{-1}$. The cohesive energy is
defined as the atomisation energy per atom keeping in mind that one gold atom
is negatively charged for the anionic clusters.

In order to discuss how much the gold cages deviate from sphericity compared to
the dual fullerene structure the previously introduced definition of a \ac{MDS}
was used,\autocite{Schwerdtfeger_Programfullerenesoftware_2013}
%
\begin{equation} 
\min\limits_{c_\mathrm{MDS} \in \mathrm{CH}(S)} \frac{1}{N} \sum _{i} \left|R_\mathrm{MDS} -\| \vec{p}_{i}-\vec{c}_\mathrm{MDS} \| \right|  
\end{equation}
with the \ac{MDS} radius defined as
\begin{equation} 
	R_{\mathrm{MDS}} =\frac{1}{N} \sum _{i}\| \vec{p}_{i} -\vec{c}_{\mathrm{MDS}} \|. 
	\label{eq:RMDS}
\end{equation}
%
Here $S$ is the set of $n$ points $\vec{p}_i$ ($i=1,\ldots ,N$) in
$3$-dimensional space, $\mathrm{CH}(S)$ its convex hull, $\|\cdot\| $ the
Euclidean norm, and $\vec{c}_\mathrm{MDS}$ is the barycentre of the \ac{MDS}
with radius $R_\mathrm{MDS}$. In other words, a sphere approximating the
distance of the vertices to the centre is searched. A measure
for distortion from spherical symmetry through the
\ac{MDS} is defined as\autocite{Schwerdtfeger_Programfullerenesoftware_2013}
%
\begin{equation}
  \label{eq:DMDS}
  D_{\mathrm{MDS}} = \frac{100}{N R_\mathrm{min}} \sum_{i=1}^N \left|R_{\mathrm{MDS}} - \|\vec{p}_i - \vec{c}_{\mathrm{MDS}}\| \right|,
\end{equation}
where $R_\mathrm{min}$ is the smallest bond distance found in the cluster. The pentagon index $N_p$ is defined as
\begin{equation}
  \label{pentindex}
  N_p = \frac{1}{2}\sum_{k=1}^{5} kp_k \quad \text{ with } \quad  \sum_{k=0}^{5} p_k = 12
\end{equation}
%
where the pentagon indices $(p_i | i=0, \dots , 5)$ define the number of
pentagons attached to another pentagon.\autocite{Fowler-atlas-2006}

\section{Computational Details for Chapter~\ref{sec:fromstickyhardspheretoLJtypeclusters}}

The \textit{pele} program~\autocite{_pelePythonenergy_2017} was used to generate putatively
complete sets of local minima for $(m,n)$-Lennard-Jones potentials 
$V_{mn}^{\mathrm LJ}(r)$ as defined in equation~\eqref{eqn:nmpot}.
This program  applies a basin-hopping algorithm that divides the potential energy
surface into basins of attraction, effectively mapping each point in
configuration space to a local minimum structure
\autocite{lis87,waless99,Wales_GlobalOptimizationBasinHopping_1997}.  The results confirmed the
number of local minima reported in previous work \autocite{Doye_Saddlepointsdynamics_2002}.
Finite computer time limited our search to clusters of size $N \leq 13$.

Starting from the sticky hard sphere packings up to $N=14$, with Cartesian
coordinates given by the exact enumeration algorithm
\autocite{Hoy_Structurefinitesphere_2012} including rigid hypostatic clusters
($N_c<3N-6$) \autocite{Holmes-Cerfon_EnumeratingRigidSphere_2016} geometry
optimisations with $(m,n)$-Lennard-Jones potentials using the multidimensional
function minimiser from the \Cpp library \textit{dlib}
\autocite{King_DlibmlMachineLearning_2009} were carried out with the previously
described program package \textsc{Spheres}
(Chapter~\ref{sec:theprogramspheres}). The optimisation scheme was either the
\ac{BFGS} or the conjugate gradient algorithm. The optimisations were terminated when the
change in energy (in reduced units) over the course of one optimizsation cycle
was smaller than $10^{-15}$. 

Subsequently, the eigenvalues of the Hessian were checked
for all stationary points. If negative eigenvalues were found, the affected
structures were reoptimized following displacements in both directions along
the corresponding eigenvectors to locate true local minima. This procedure assures
that the floppy \ac{SHS} packings are successfully mapped into LJ minima.

As the optimisations often result in many duplicates, especially for small
values of $n$ and $m$ where $|\mathcal{M}_{(m,n)\mathrm{-LJ}}| \ll
|\mathcal{M}_\mathrm{SHS}|$, the final structures were further analysed and
sorted. Nonisomorphic \ac{SHS} clusters can be distinguished (apart from
permutation of the particles) by their different adjacency matrices for $N \leq
13$ \autocite{Holmes-Cerfon_EnumeratingRigidSphere_2016}.  This is not the case
for soft potentials like the LJ potential since drawing edges (bonds) between
the vertices (atoms) becomes a matter of defining the distance cutoff criterion
for a bond to be drawn. Therefore, the clusters were compared based on the
\ac{EDM} (the matrix of interparticle distances $\{r_{ij}\}$) as described
previously: two clusters are isomorphic (structurally identical) if they have
the same ordered set of inter-particle distances $\{r_{ij}\}$.  While
enantiomers cannot be separated using this methodology, permutation-inversion
isomers are usually lumped together, since the number of distinct minima is
analytically related to the order of the corresponding point group
\autocite{wales04}.  To verify the number of distinct structures we introduced
a second ordering scheme using the energy and moment of inertia tensor
eigenvalues. 

Two sets of structures are obtained from our optimization procedure: the first
set contains all possible LJ minima $\mathcal{M}_\mathrm{LJ}$ from the
basin-hopping algorithm, while the second set $\mathcal{M}_\mathrm{SHS\to LJ}$
contains the LJ minima obtained using only the $\mathcal{M}_\mathrm{SHS}$
sticky-hard-sphere cluster structures as starting points for the geometry
optimization.  To compare and identify corresponding structures between the two
sets, the $N(N-1)/2$ inter-particle distances $\{r_{ij}\}$ were again used as
an identifying fingerprint.

Two-body \ac{eLJ} potentials that accurately model
two-body interactions in rare-gas clusters can be written as expansions of
inverse-power-law terms
\autocite{Schwerdtfeger_ExtensionLennardJonespotential_2006}:
%
\begin{equation} \label{eq:ELJ}
V_{\mathrm ELJ}(r)=\sum_{n} c_nr^{-n},
\end{equation}
%
where in reduced units the condition $\sum_{n} c_n=-1$ holds. For comparison
to the simple (6,12)-\ac{LJ} potential, the \ac{eLJ} potential derived from
relativistic coupled-cluster theory applied to the xenon dimer was used with the
following coefficients (in reduced units):
$c_6=-1.0760222355$; $c_8=-1.4078314494$; $c_9=-185.6149933139$;
$c_{10}=+1951.8264493941$; $c_{11}=-8734.2286559729$;
$c_{12}=+22273.3203327203$; $c_{13}=-35826.8689874832$;
$c_{14}=+37676.9744744424$; $c_{15}=-25859.2842295062$;
$c_{16}=+11157.4331408911$; $c_{17}=-2745.9740079192$; $c_{18}=+293.9003309498$
\autocite{Jerabek_relativisticcoupledclusterinteraction_2017}. The \ac{eLJ}
potential for xenon is shown in figure~\ref{fig:LJ} (dashed line).

\section{Computational Details for Chapter~\ref{sec:thegregorynewtonclusters}}

Coordinates for \ac{GNC} structures have been obtained by searching for
adjacency matrices of the results for $N=13$ from
\citeauthor{Holmes-Cerfon_EnumeratingRigidSphere_2016}
\autocite{Holmes-Cerfon_EnumeratingRigidSphere_2016} with one row or column
containing twelve ``1'' entries. Sub-graph isomorphism was verified using the
\textit{VF2} algorithm \autocite{Cordella_SubGraphIsomorphism_2004} as
implemented in the \textit{boost graph library}
\autocite{Siek_BoostGraphLibrary_2002} using the program package
\textsc{Spheres}. Structural optimisations with \ac{LJ} potentials have been carried
out using the multidimensional function minimiser from the \Cpp library
\textit{dlib} \autocite{King_DlibmlMachineLearning_2009} and an energy
convergence criterion of $10^{-15}$. Results from the optimisation procedure
were analysed based on the \ac{EDM}, which is unique for
non-isomorphic structures apart from permutation, translation, rotation and
inversion. For this the distances were sorted lexicographically.
